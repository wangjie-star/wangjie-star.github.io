[{"title":"linux命令汇总","url":"/86e57d597029/","content":"\n","tags":["IT运维"]},{"title":"C函数在调用return退出时出现段错误的可能原因","url":"/cfcb83679091/","content":"\n&emsp;&emsp;可能性最大的在当前调用函数的文件中未引入头文件，导致截断（有的系统默认指针是 4 个\n字节，64 位系统指针是 8 个字节，但是在函数未定义的情况下，系统默认回传 4 个字节的指针，\n就会导致指针高 4 位未被回传，系统就会默认会将高 4 位填充成 FFFF，导致指针地址出错），\n出现的段错误。\n","tags":["gdb"]},{"title":"PostgreSQL-bufmmgr","url":"/b17ff0458240/","content":"## 一、 缓冲区管理器的结构\n\nPostgreSQL缓冲区管理器由三层组成，即**缓冲表层**，**缓冲区描述符层**和**缓冲池层**\n<!-- more -->\n![](/images/bufmgr.png)\n\n- **缓冲表（buffer table）**层是一个哈希表，它存储着页面的`buffer_tag`与描述符的`buffer_id`之间的映射关系。\n- **缓冲区描述符（buffer descriptors）**层是一个由缓冲区描述符组成的数组。 每个描述符与缓冲池槽一一对应，并保存着相应槽的元数据。\n- **缓冲池（buffer pool）**层是一个数组。 每个槽都存储一个数据文件页，数组槽的索引称为`buffer_id`。\n\n### 1、缓冲表\n\n缓冲表分为三个部分：散列函数（hash function）、散列桶槽（buckets slots）、数据项（data entries）。\n\n内置散列函数将buffer_tag映射到哈希桶槽。可能会发生冲突，采用了使用链表的分离链接方法来解决冲突。\n\n![](/images/buffer_table.png)\n\n```c\ntypedef struct RelFileNode\n{\n\tOid\t\t\tspcNode;\t\t/* tablespace */\n\tOid\t\t\tdbNode;\t\t\t/* database */\n\tOid\t\t\trelNode;\t\t/* relation */\n} RelFileNode;\n\n/* buftag对应的数据结构 */\ntypedef struct buftag\n{\n\tRelFileNode rnode;\t\t/* physical relation identifier */\n\tForkNumber\tforkNum;        /* 关系的分支编号 */\n\tBlockNumber blockNum;\t\t/* blknum relative to begin of reln */\n} BufferTag;\n```\n\n### 2、缓冲区描述符\n\n缓冲区描述符保存着页面的元数据，这些与缓冲区描述符对应的页面保存在缓冲池槽中。\n\n```c\n/* 缓冲区描述符对应的数据结构 */\ntypedef struct BufferDesc\n{\n\tBufferTag\ttag;\t\t\t/* ID of page contained in buffer; 存储在缓冲区中页面的标识 */\n\tint\t\tbuf_id;\t\t\t/* buffer's index number (from 0); 缓冲的索引编号（从0开始） */\n\n\t/* state of the tag, containing flags, refcount and usagecount */\n\tpg_atomic_uint32 state; \t\t/* tag的状态, 包含flags（标记位）, refcount（在本缓冲区上持有PIN的后端进程数）\n\t                          \t\t , usagecount（时钟扫描要用到的引用计数）*/\n                                \t\t/* 其中 flags保存的状态有以下几种：\n                               \t   \t\t     1.脏位指明相应页面是否为脏页\n                               \t   \t\t     2.有效位指明相应页面是否可以被读写\n                               \t   \t\t     3.IO进行标记位指明缓冲区管理器是否正在从存储中读/写相应页面 */\n\n\tint\t       wait_backend_pid;\t/* backend PID of pin-count waiter; 等着PIN本缓冲区的后端进程PID */\n\tint\t       freeNext;\t\t/* link in freelist chain; 空闲链表中的链接 */\n\tLWLock\t       content_lock;\t        /* to lock access to buffer contents; 访问缓冲区内容的锁 */\n} BufferDesc;\n```\n\n缓冲区描述符有三种状态：\n\n- **空**：当相应的缓冲池槽不存储页面时，即refcount与usagecount都是0，该描述符的状态为空。\n- **钉住**：当相应的缓冲池槽中存储着页面，且有PG进程正在访问相应页面时，即refcount与usagecount都大于等于1，该缓冲区描述符的状态为钉住。\n- **未钉住**：当相应的缓冲池槽中存储着页面，且没有PG进程正在访问相应页面时，即usagecount大于或等于1，但refcount为0，该描述符的状态为未钉住。\n\n### 3、缓冲池\n\n缓冲池只是一个用于存储关系数据文件（例如表或索引）页面的简单数组。缓冲池数组的序号索引就是buffer_id。\n\n缓冲池槽的大小为8KB，等于页面大小，因此每个槽都能存储整个页面。\n\n## 二、缓冲区管理器的工作原理\n\n当后端进程想要访问所需页面时，它会调用 **ReadBufferExtended** 函数。\n\n函数 ReadBufferExtended 的行为因场景而异，在逻辑上具体可以分为三种情况。\n\n### 1、访问存储在缓冲池中的页面\n\n**流程描述：**\n\n1. 创建所需页面的buffer tag，计算hash值；\n\n2. 获取BufMappingLock分区锁，加shared锁；\n\n3. 从buffer hashtable中找到buffer tag，获取buffer id；\n\n4. 根据buffer id获取buffer descriptor；pin buffer；释放BufMappingLock分区锁；\n\n5. 从Buffer Pool中获取buffer id对应的page。\n\n   - 在具体读取页面的行时，进程持有对应buffer descriptor的shared content_lock，多个进程可以并发读取。\n\n   - 当修改该页面的行时，进程获取exclusive content_lock，dirty bit也要设为1。\n\n   - 在获取页面后，对应的refcount要加1。\n\n### 2、将页面从存储加载到空槽\n\n**流程描述：**\n\n\t1、查找buffer hashtable，没有找到对应的buffer tag；\n\n\t2、从freelist中获取第一个空的buffer descriptor，pin住\n\n\t\t1）获取buffer_strategy_lock自旋锁\n\n\t\t2）从空闲列表中弹出一个可用的buffer descriptor\n\n\t\t3）释放buffer_strategy_lock自旋锁\n\n\t\t4）pin buffer\n\n\t3、获取BufMappingLock分区锁，加exclusive锁；\n\n\t4、创建包含buffer tag和buffer id的hash entry，插入buffer hashtable；\n\n\t5、从存储中加载指定页到buffer pool，使用buffer id为数组下标\n\n\t\t1）获取exclusive io_in_progress_lock\n\n\t\t2）io_in_progress bit置1，防止其他进程获取buffer descriptor\n\n\t\t3）从存储中加载指定页到buffer pool\n\n\t\t4）修改buffer descriptor的状态，io_in_progress bit置0，valid bit置1\n\n\t\t5）释放io_in_progress_lock\n\n\t6、释放BufMappingLock分区锁；\n\n\t7、从Buffer Pool中获取buffer id对应的page；\n\n### 3、将页面从存储加载到受害者缓冲池槽\n\n**流程描述：**\n\n\t1、查找buffer hashtable，没有找到对应的buffer tag；\n\n\t2、使用clock-sweep算法选中牺牲的buffer pool槽位，在buffer hashtable中获取包含牺牲槽位buffer id的旧表项，在buffer descriptor中pin住牺牲槽位；\n\n\t3、flush（write和fsync）牺牲槽位的页表数据，否则直接到4；\n\n\t\t 脏页必须先落盘，所占的slot才能被牺牲。刷脏包括以下步骤：\n\n\t\t1）获取buffer descriptor的shared content_lock和exclusive io_in_progress_lock\n\n\t\t2）修改buffer descriptor状态，io_in_progress bit置1，drity bit置0\n\n\t\t3）根据具体情况，使用XLogFlush将WAL缓冲区的WAL写入WAL段文件\n\n\t\t4）flush牺牲页\n\n\t\t5）修改buffer descriptor状态，io_in_progress置0，valid bit置1\n\n\t\t6）释放io_in_progress_lock和content_lock\n\n\t4、获取旧页表的exclusive BufMappingLock分区锁；\n\n\t5、获取新页表的exclusive BufMappingLock分区锁，添加到buffer table\n\n\t\t1）创建包含新buffer tag和buffer id的hash entry\n\n\t\t2）获取新的exclusive BufMappingLock分区锁\n\n\t\t3）插入到buffer hashtable\n\n\t6、删除buffer hashtable中旧的hash entry，释放旧的BufMappingLock分区锁；\n\n\t7、从存储中加载到牺牲slot，更新buffer descriptor的flag：dirty位置0，初始化其他bit；\n\n\t8、释放新的BufMappingLock分区锁；\n\n\t9、从Buffer Pool中获取指定buffer id对应的page；\n","tags":["DBMS"],"categories":["PostgreSQL"]},{"title":"PostgreSQL-调试initdb","url":"/0f842baa5beb/","content":"1、gdb ./bin/initdb\n2、set args -D ./data\n3、在initdb.c 中打断点，最好位置设置在initialize_data_directory函数的setup_auth(cmdfd);\n4、运行程序 r (run)\n5、启动新窗口，查找进程，ps -ux\n 找到postgres --single -F -O -j -c search_path=pg_catalog -c exit_on_error=true template1\n6、在新启动的窗口调试进程 （gdb att procid）\n","tags":["DBMS"],"categories":["PostgreSQL"]},{"title":"PostgreSQL-并发控制","url":"/13ddc1c017f3/","content":"## 一、事务标识\n\n当事务开始时，事务管理器会为其分配一个事务标识（txid）的唯一标识符。\n\nPostgreSQL有三个特殊txid:\n\n- 0标识无效的txid；\n- 1表示初始启动的txid，仅用于数据库集群的初始化过程；\n- 2表示冻结的txid。\n<!-- more -->\n txid在逻辑上是无限的，但实际系统的txid空间不足（4B整型的取值空间大小约42亿），因此Postgresql将txid空间视为一个环。对于某个txid，其前21亿个txid属于过去，其后约21亿个txid属于未来。\n\n## 二、元组结构\n\n```c\ntypedef struct HeapTupleFields\n{\n\tTransactionId t_xmin;\t\t/* inserting xact ID; 插入事务的ID */\n\tTransactionId t_xmax;\t\t/* deleting or locking xact ID; 删除或锁定事务的ID */\n\n\tunion\n\t{\n\t\tCommandId\tt_cid;\t\t/* inserting or deleting command ID, or both; 插入或删除的命令ID */\n\t\tTransactionId t_xvac;\t/* old-style VACUUM FULL xact ID; 老式VACUUM FULL的事务ID */\n\t}\t\t\tt_field3;\n} HeapTupleFields;\n\nstruct HeapTupleHeaderData\n{\n\tunion\n\t{\n\t\tHeapTupleFields t_heap;\n\t\tDatumTupleFields t_datum;\n\t}\t\t\tt_choice;\n\n    //当前元组或更新元组的TID\n\tItemPointerData t_ctid;\t\t/* current TID of this or newer tuple (or a\n\t\t\t\t\t\t\t\t * speculative insertion token) */\n\n\t/* Fields below here must match MinimalTupleData! */\n\n#define FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK2 2\n\tuint16\t\tt_infomask2;\t/* number of attributes + various flags */\n#define FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK 3\n\tuint16\t\tt_infomask;\t\t/* various flag bits, see below */ //主要保存了事务的状态标记位\n#define FIELDNO_HEAPTUPLEHEADERDATA_HOFF 4\n\tuint8\t\tt_hoff;\t\t\t/* sizeof header incl. bitmap, padding */\n\n\t/* ^ - 23 bytes - ^ */\n\n#define FIELDNO_HEAPTUPLEHEADERDATA_BITS 5\n\tbits8\t\tt_bits[FLEXIBLE_ARRAY_MEMBER];\t/* bitmap of NULLs */\n\n\t/* MORE DATA FOLLOWS AT END OF STRUCT */\n};\n```\n---\n\n![](/images/tuple.png)\n\nt_xmin：代表插入此元组的事务xid；\n\nt_xmax：代表更新或者删除此元组的事务xid，如果该元组插入后未进行更新或者删除，t_xmax=0；\n\nt_cid：command id，代表在当前事务中，已经执行过多少条sql，例如执行第一条sql时cid=0，执行第二条sql时cid=1；\n\nt_ctid：保存着指向自身或者新元组的元组标识（tid），由两个数字组成，第一个数字代表物理块号，或者叫页面号，第二个数字代表元组号。在元组更新后tid指向新版本的元组，否则指向自己，这样其实就形成了新旧元组之间的“元组链”，这个链在元组查找和定位上起着重要作用。\n\n## 三、元组的增、删、改\n\n### 1、更新元组\n\n![](/images/tuple_update.png)\n\n左图是一条新插入的元组，可以看到元组是xid=100的事务插入的，没有进行更新，所以t_xmax=0，同时t_ctid指向自己，0号页面的第一号元组。\n右图是发生xid=101的事务更新该元组后的状态，更新在pg里相当于插入一条新元组，原来的元组的t_xmax变为了更新这条事务的xid=101，同时t_ctid指针指向了新插入的元组（0,2），0号页面第二号元组，第二号元组的t_xmin=101（插入该元组的xid），t_ctid=（0,2），没有发生更新，指向自己。\n\n### 2、删除元组\n\n![](/images/tuple_delete.png)\n\n上图代表该元组被xid=102的事务删除，将t_xmax设置为删除事务的xid，t_ctid指向自己。\n\n## 四、提交日志（clog）\n\nPostgresql在提交日志（CLOG）中保存事务的状态。CLOG分配于共享内存中，并用于事务处理过程的全过程。\n\n每次事务提交和回滚的时候，都需要更新该状态（调用CommitTransactionCommand(void)），PostgreSQL服务器访问该文件确定事务的状态，保存在pg_xact目录中，每个文件大小为256KB，每个事务2位（bit），故1个文件可以包含131072个事务。对于第一次修改的数据行来说，因为事务状态存储在clog中，所以修改后第一次判断行的可见性需要通过访问clog来确定，而访问clog是一个非常耗费性能的过程，\n\n### 1、事务状态\n\n- IN_PROGRESS\n- COMMITTED\n- ABORTED\n- SUB_COMMITTED\n\n```c\n/*\n * Possible transaction statuses --- note that all-zeroes is the initial\n * state.\n *\n * A \"subcommitted\" transaction is a committed subtransaction whose parent\n * hasn't committed or aborted yet.\n */\ntypedef int XidStatus;\n\n#define TRANSACTION_STATUS_IN_PROGRESS\t\t0x00\n#define TRANSACTION_STATUS_COMMITTED\t\t0x01\n#define TRANSACTION_STATUS_ABORTED\t\t\t0x02\n#define TRANSACTION_STATUS_SUB_COMMITTED\t0x03\n```\n\n### 2、事务特性\n\n```c\n/* We need two bits per xact, so four xacts fit in a byte */\n/* pg中通过2个bit位来标识4种事务状态(0、1、2、3)，那么1个字节便可以存储4个事务，对于1个8k的page则可以存储8k * 4 = 32k个事务。 */\n#define CLOG_BITS_PER_XACT\t2\n#define CLOG_XACTS_PER_BYTE 4\n#define CLOG_XACTS_PER_PAGE (BLCKSZ * CLOG_XACTS_PER_BYTE)\n#define CLOG_XACT_BITMASK\t((1 << CLOG_BITS_PER_XACT) - 1)\n\n#define TransactionIdToPage(xid)\t((xid) / (TransactionId) CLOG_XACTS_PER_PAGE)  // 通过xid获取页\n#define TransactionIdToPgIndex(xid) ((xid) % (TransactionId) CLOG_XACTS_PER_PAGE)  // 获取xid在页中的索引\n#define TransactionIdToByte(xid)\t(TransactionIdToPgIndex(xid) / CLOG_XACTS_PER_BYTE)  // 获取xid在页中的位置（第几个字节）\n#define TransactionIdToBIndex(xid)\t((xid) % (TransactionId) CLOG_XACTS_PER_BYTE) // 获取xid在页中的位置（在某个字节中位于第几个事务）\n```\n\n- 事务id并不是在事务开始时就会被分配，而是当事务进行了数据修改之类的操作时才会分配xid，而当事务提交或回滚时，其事务状态便会被写入clog中。\n\n- 前一个事务所有修改的数据，它没有在提交或者回滚的当时改掉所有的修改标记，而是等到下次查询时进行修改（为了提升性能）。\n\n## 五、事务快照\n\n### 1、快照定义\n\n事务快照在postgresql中的文本表示格式为xmin:xmax:xip_list。100:100：意味着txid < 100的事务处于非活跃状态，而txid ≥ 100的事务处于活跃状态。\n\n![](/images/snapshot.png)\n\n**100:100：含义如下**\n\n- xmin=100，所以txid<100的事务均不活跃\n- xmax=100，所以txid>=100的事务均活跃或未启动\n- xip_list为空，表示[xmin,xmax)范围内无活跃事务\n\n**100:104:100,102含义如下**\n\n- xmin=100，所以txid<100的事务均不活跃\n- xmax=104，所以txid>=104的事务均活跃或未启动\n- xip_list为100,102，表示[xmin,xmax)范围内100,102为活跃事务\n\n### 2、快照与隔离级别\n\npg会根据不同隔离级别设置，获取不同时刻的快照：\n\n-  **已提交读：在该事务的每条SQL执行之前都会重新获取一次快照**\n- **可重复读和可串行化：该事务只在第一条SQL执行之前获取一次快照** \n\n![](/images/snapshot_trans.png)\n\n```c\n// 快照相关的数据结构\ntypedef struct SnapshotData\n{\n\tSnapshotType snapshot_type; /* type of snapshot; 事务类型 */ \n\n\t/*\n\t * The remaining fields are used only for MVCC snapshots, and are normally\n\t * just zeroes in special snapshots.  (But xmin and xmax are used\n\t * specially by HeapTupleSatisfiesDirty, and xmin is used specially by\n\t * HeapTupleSatisfiesNonVacuumable.)\n\t *\n\t * An MVCC snapshot can never see the effects of XIDs >= xmax. It can see\n\t * the effects of all older XIDs except those listed in the snapshot. xmin\n\t * is stored as an optimization to avoid needing to search the XID arrays\n\t * for most tuples.\n\t */\n\tTransactionId xmin;\t\t\t/* all XID < xmin are visible to me; 若事务ID小于xmin，则对当前事务可见 */\n\tTransactionId xmax;\t\t\t/* all XID >= xmax are invisible to me; 若事务ID大于xmax，则对当前事务不可见 */\n\n\t/*\n\t * For normal MVCC snapshot this contains the all xact IDs that are in\n\t * progress, unless the snapshot was taken during recovery in which case\n\t * it's empty. For historic MVCC snapshots, the meaning is inverted, i.e.\n\t * it contains *committed* transactions between xmin and xmax.\n\t *\n\t * note: all ids in xip[] satisfy xmin <= xip[i] < xmax\n\t */\n\tTransactionId *xip;  //  快照生成时对应的活跃事务列表\n\tuint32\t\txcnt;\t\t\t/* # of xact ids in xip[]; xip数组大小 */\n\n\t/*\n\t * For non-historic MVCC snapshots, this contains subxact IDs that are in\n\t * progress (and other transactions that are in progress if taken during\n\t * recovery). For historic snapshot it contains *all* xids assigned to the\n\t * replayed transaction, including the toplevel xid.\n\t *\n\t * note: all ids in subxip[] are >= xmin, but we don't bother filtering\n\t * out any that are >= xmax\n\t */\n\tTransactionId *subxip; // 活跃的子事务列表\n\tint32\t\tsubxcnt;\t\t/* # of xact ids in subxip[]; sub xip数组大小 */\n\tbool\t\tsuboverflowed;\t/* has the subxip array overflowed? ;当子事务过多时，数组有可能overflow */\n\n\tbool\t\ttakenDuringRecovery;\t/* recovery-shaped snapshot? */\n\tbool\t\tcopied;\t\t\t/* false if it's a static snapshot; 如果是静态快照则为false */\n\n\tCommandId\tcurcid;\t\t\t/* in my xact, CID < curcid are visible */\n\n\t/*\n\t * An extra return value for HeapTupleSatisfiesDirty, not used in MVCC\n\t * snapshots.\n\t * \n\t * HeapTupleSatisfiesDirty使用的一个变量，在判断可见性的同时，会借助这\n\t * 个变量将元组上的speculativeToken返回给上层\n\t */\n\tuint32\t\tspeculativeToken;\n\n\t/*\n\t * For SNAPSHOT_NON_VACUUMABLE (and hopefully more in the future) this is\n\t * used to determine whether row could be vacuumed.\n     * 元组是否可vacuum（用于SNAPSHOT_NON_VACUUMABLE状态）\n\t */\n\tstruct GlobalVisState *vistest;\n\n\t/*\n\t * Book-keeping information, used by the snapshot manager\n\t */\n\tuint32\t\tactive_count;\t/* refcount on ActiveSnapshot stack */\n\tuint32\t\tregd_count;\t\t/* refcount on RegisteredSnapshots */\n\tpairingheap_node ph_node;\t/* link in the RegisteredSnapshots heap */\n\n\tTimestampTz whenTaken;\t\t/* timestamp when snapshot was taken */\n\tXLogRecPtr\tlsn;\t\t\t/* position in the WAL stream when taken */\n\n\t/*\n\t * The transaction completion count at the time GetSnapshotData() built\n\t * this snapshot. Allows to avoid re-computing static snapshots when no\n\t * transactions completed since the last GetSnapshotData().\n\t */\n\tuint64\t\tsnapXactCompletionCount;\n} SnapshotData;\n```\n\n\n\n## 六、可见性检查\n\n**事务并发可能出现的现象：**\n\n- 脏读：某一事务读取了另一个事务未提交的脏数据。\n\n- 幻读：读取了前一事务提交的数据（针对的是一批数据整体，比如数据的个数 ）。\n- 不可重复读：读取了前一事务提交的数据（查询的都是 同一个数据项 ）。 \n\n**事务隔离级别：**\n\n- READ UNCOMMITTED（读未提交）------ postgresql不存在这个隔离级别，所以不会出现脏读的现象。\n- READ COMMITTED（读已提交）------ 可能会发生幻读和不可重复读。\n- REPEATABLE READ（可重复读）------ 不会发生幻读和不可重复读（标准sql事务隔离级别允许幻读）。\n- SERIALIZABLE（序列化）------ 不会发生幻读和不可重复读。\n\n| 隔离级别 | 脏读   | 不可重复读 | 幻读                   |\n| -------- | ------ | ---------- | ---------------------- |\n| 读未提交 | 可能   | 可能       | 可能                   |\n| 读已提交 | 不可能 | 可能       | 可能                   |\n| 可重复读 | 不可能 | 不可能     | Allowed, but not in PG |\n| 可串行化 | 不可能 | 不可能     | 不可能                 |\n\n**元组的可见性:**\n\n确定一条元组是否对一个事务可见，可见性检查规则会用到元组的t_xmin和t_xmax,提交日志ClOG，以及已获取的事务快照。\n\nt_xmin状态为 ABORTED的元组始终不可见\n\nt_xmin状态为IN_PROGRESS的元组基本上是不可见的（对自身事务可见）\n\nt_xmin状态为COMMITTED的元组是可见的\n","tags":["DBMS"],"categories":["PostgreSQL"]},{"title":"PostgreSQL-xlog","url":"/b3574ee3d8f5/","content":"## 一、xlog存储结构\n\n​\t\t每个XLOG文件有一个ID，一个逻辑上的xlog文件物理上被分割成一个个固定大小的段（默认16MB）。xlog文件号和段号可以唯一确定某个段文件。确定日志文件内的一个日志记录的地址时，只需要xlog文件号和日志记录在该文件内的偏移量即可。\n<!-- more -->\n​\t\t对于每一个Xlog文件第一个段的第一个页面是一个长头部（Long Header），一个xlog文件头部是不是长头部，可以由其头部XLogPageHeaderData的标志位xlp_info确定出来，如果是长头部，则：\nXLogPageHeader page;\npage->xlp_info = XLP_LONG_HEADER;\n\n### 1、xlog日志页面头部信息\n\n​\t\txlog日志文件分为许多的逻辑段，每一个段文件又分成许多个页面，每一个页面大小为一个块的大小。对于每一个日志页面，需要在其头部写一个头部信息XLogPageHeaderData，其结构如下：\n\n```c\n#define XLOG_PAGE_MAGIC 0xD093\t/* can be used as WAL version indicator */\n\ntypedef struct XLogPageHeaderData\n{\n\tuint16\t\txlp_magic;\t\t/* 用于正确性检查的魔数 */\n\tuint16\t\txlp_info;\t\t/* 标记位 */\n\tTimeLineID\txlp_tli;\t\t/* 页面中第一条记录的时间线ID */\n\tXLogRecPtr\txlp_pageaddr;\t/* 当前页面的XLOG地址 */\n\t/*\n\t * 当当前页面放不下一条完整记录时，我们会在下一个页面继续放，xlp_rem_len存储了先前页面\n\t * 记录剩余的字节数。注意，xlp_rem_len包含了备份区块的数据，也就是说它会在第一个首部跟\n\t * 踪xl_tot_len而不是xl_len。还要注意，数据不一定是对齐的。\n\t */\n\tuint32\t\txlp_rem_len;\t/* total len of remaining data for record */\n} XLogPageHeaderData;\n\n#define SizeOfXLogShortPHD\tMAXALIGN(sizeof(XLogPageHeaderData))\n\ntypedef XLogPageHeaderData *XLogPageHeader;\n```\n\n​\t\t如果一个页面是一个逻辑段文件的第一个页面，那么在页面头部信息标志位会设置XLP_LONG_HEADER标记，那么将在原页面头部信息的基础上使用一个长的XLOG页面头部XLogLongPageHeaderData，其结构如下：\n\n```c\n/*\n * 当xlp_info设置了XLP_LONG_HEADER标记位时，我们将在页首部中存储额外的字段。\n * (通常是在XLOG文件中的第一个页面中)额外的字段用于确保文件的正确性。\n */\ntypedef struct XLogLongPageHeaderData\n{\n\tXLogPageHeaderData std;\t\t/* 标准首部 */\n\tuint64\t\txlp_sysid;\t\t/* 来自pg_control中的系统标识符 */\n\tuint32\t\txlp_seg_size;\t/* 交叉校验 */\n\tuint32\t\txlp_xlog_blcksz;/* 交叉校验 */\n} XLogLongPageHeaderData;\n\n#define SizeOfXLogLongPHD\tMAXALIGN(sizeof(XLogLongPageHeaderData))\n\ntypedef XLogLongPageHeaderData *XLogLongPageHeader;\n```\n\n### 2、xlog日志记录结构信息\n\n​\tXLOG Record由两部分组成，第一部分是XLOG Record的头部信息，大小固定（24 Bytes），对应的结构体是**XLogRecord**；第二部分是**XLOG Record data**。\n\nxlog记录存储布局：\n\n```c\nFixed-size header (XLogRecord struct)\nXLogRecordBlockHeader struct\nXLogRecordBlockHeader struct\n…\nXLogRecordDataHeader[Short|Long] struct\nblock data\nblock data\n…\nmain data\n```\n\n#### 1）XLogRecord\n\n**XLOG Record**按存储的数据内容来划分，大体可以分为三类：\n\n- Record for backup block：存储full-write-page的block，这种类型Record是为了解决page部分写的问题。在checkpoint完成后第一次修改数据page，在记                   \t\t\t\t\t\t\t\t\t\t\t   录此变更写入事务日志文件时整页写入（需设置参数full_page_write，默认为打开）；\n\n- Record for tuple data block：存储page中的tuple变更，使用这种类型的Record记录；\n\n- Record for Checkpoint：在checkpoint发生时，在事务日志文件中记录checkpoint信息。\n\nXLogRecord记录了Xlog记录的相关控制信息:\n\n```c\n//日志之间有链接关系，xl_prev指向上一条日志的起始位置，下一条日志的位置用xl_tot_len可以找到，日志之间形成“双向链表”。\ntypedef struct XLogRecord\n{\n    //整条XLog记录的长度\n\tuint32\t\txl_tot_len;\t\t/* total len of entire record */\n    //事务ID\n\tTransactionId xl_xid;\t\t/* xact id */\n    //上一条日志的LSN\n\tXLogRecPtr\txl_prev;\t\t/* ptr to previous record in log */\n    //产生这个记录的动作，xl_info低4位保存flag信息，高4位保存日志动作信息。\n\tuint8\t\txl_info;\t\t/* flag bits, see below */\n    //日志记录对应的资源管理器\n\tRmgrId\t\txl_rmid;\t\t/* resource manager for this record */\n\t/* 2 bytes of padding here, initialize to zero */\n    //本记录的CRC\n\tpg_crc32c\txl_crc;\t\t\t/* CRC for this record */\n\n\t/* XLogRecordBlockHeaders and XLogRecordDataHeader follow, no padding */\n\n} XLogRecord;\n```\n\n其中，xl_info被资源管理器使用，表示该日志是哪种类型的日志，其取值如下：\n\n```c++\n/* XLOG info values for XLOG rmgr */\n#define XLOG_CHECKPOINT_SHUTDOWN\t\t0x00\n#define XLOG_CHECKPOINT_ONLINE\t\t\t0x10\n#define XLOG_NOOP\t\t\t\t\t\t0x20\n#define XLOG_NEXTOID\t\t\t\t\t0x30\n#define XLOG_SWITCH\t\t\t\t\t\t0x40\n#define XLOG_BACKUP_END\t\t\t\t\t0x50\n#define XLOG_PARAMETER_CHANGE\t\t\t0x60\n#define XLOG_RESTORE_POINT\t\t\t\t0x70\n#define XLOG_FPW_CHANGE\t\t\t\t\t0x80\n#define XLOG_END_OF_RECOVERY\t\t\t0x90\n#define XLOG_FPI_FOR_HINT\t\t\t\t0xA0\n#define XLOG_FPI\t\t\t\t\t\t0xB0\n/* 0xC0 is used in Postgres 9.5-11 */\n#define XLOG_OVERWRITE_CONTRECORD\t\t0xD0\n```\n\n#### 2）XLOG Record data\n\n**XLOG Record data**是存储实际数据的地方，由以下几部分组成：\n\n- 0…N个XLogRecordBlockHeader，每一个XLogRecordBlockHeader对应一个block data；\n\n- XLogRecordDataHeader[Short|Long]，如数据大小<256 Bytes，则使用Short格式，否则使用Long格式；\n\n- block data：full-write-page data和tuple data。对于full-write-page data，如启用了压缩，则数据压缩存储，压缩后该page相关的元数据存储在XLogRecordBlockCompressHeader中。block data的个数和XLogRecordBlockHeader对应；\n\n- main data： checkpoint等日志数据.\n\n------\n\n##### （1）BLOCK\n\n###### ①XLogRecordBlockHeader\n\n```c\ntypedef struct XLogRecordBlockHeader\n{\n    //【一个记录中可以有多个block（MAX: 32），此id是block的序号】\n\tuint8\t\tid;\t\t\t\t/* block reference ID */\n    //【关系中的分支，以及标记位】\n\tuint8\t\tfork_flags;\t\t/* fork within the relation, and flags */\n    //【决定tupledata中存储的数据的长度(不包括page image)】\n\tuint16\t\tdata_length;\t/* number of payload bytes (not including page\n\t\t\t\t\t\t\t\t * image) */\n\n\t/* If BKPBLOCK_HAS_IMAGE, an XLogRecordBlockImageHeader struct follows */\n\t/* If BKPBLOCK_SAME_REL is not set, a RelFileNode follows */\n\t/* BlockNumber follows */\n} XLogRecordBlockHeader;\n```\n\n------\n\n###### ②XLogRecordBlockImageHeader\n\nwal记录是一个full page write记录时，存在此结构\n\n```c\ntypedef struct XLogRecordBlockImageHeader\n{\n    //【保存的page的总长度（去除空洞数据、且压缩后的长度）】\n\tuint16\t\tlength;\t\t\t/* number of page image bytes */\n    //【空洞前面的字节数】\n\tuint16\t\thole_offset;\t/* number of bytes before \"hole\" */\n    //【标志位，记录是否包含空洞数据，是否进行了压缩】\n\tuint8\t\tbimg_info;\t\t/* flag bits, see below */\n\n\t/*\n\t * If BKPIMAGE_HAS_HOLE and BKPIMAGE_IS_COMPRESSED, an\n\t * XLogRecordBlockCompressHeader struct follows.\n\t */\n} XLogRecordBlockImageHeader\n\n// bimg_info可能的取值如下：\n/* Information stored in bimg_info */\n#define BKPIMAGE_HAS_HOLE\t\t0x01\t/* page image has \"hole\" */\n#define BKPIMAGE_IS_COMPRESSED\t0x02\t/* page image is compressed */\n```\n\n###### ③XLogRecordBlockCompressHeader\n\n此结构记录空洞数据的大小\n\n```c\n/*\n * Extra header information used when page image has \"hole\" and\n * is compressed.\n */\ntypedef struct XLogRecordBlockCompressHeader\n{\n\tuint16\t\thole_length;\t/* number of bytes in \"hole\" */\n} XLogRecordBlockCompressHeader;\n```\n\n###### ④RelFileNode\n\n此结构记录了此block所属的表。如果当前block与前一个block来源于同一个表时，那么fork_flags中就不会有BKPBLOCK_SAME_REL标志位\n\n```c\ntypedef struct RelFileNode\n{\n\tOid\t\t\tspcNode;\t\t/* tablespace */\n\tOid\t\t\tdbNode;\t\t\t/* database */\n\tOid\t\t\trelNode;\t\t/* relation */\n} RelFileNode;\n```\n\n###### ⑤BlockNumber\n\n记录此block记录的page的块号。\n\n------\n\n##### （2）XLogRecordDataHeaderLong/XLogRecordDataHeaderShort\n\n此结构被record中的maindata(checkpoint等日志数据)部分使用，当maindata的size小于256时使用XLogRecordDataHeaderShort结构\n否则使用XLogRecordDataHeaderLong结构\n\n```c\ntypedef struct XLogRecordDataHeaderShort\n{\n\tuint8\t\tid;\t\t\t\t/* XLR_BLOCK_ID_DATA_SHORT */\n\tuint8\t\tdata_length;\t/* number of payload bytes */\n}\tXLogRecordDataHeaderShort;\n\n\ntypedef struct XLogRecordDataHeaderLong\n{\n\tuint8\t\tid;\t\t\t\t/* XLR_BLOCK_ID_DATA_LONG */\n\t/* followed by uint32 data_length, unaligned */\n}\tXLogRecordDataHeaderLong;\n```\n\n##### （3）block data（区块数据与XLogRecordBlockHeader对应）\n\nblock data包含full-write-page data（全页写日志记录）和tuple data（更新日志记录）两种类型数据\n\n##### （4）main data（主数据与XLogRecordDataHeader对应）\n\nmain data部分保存非buff性的数据，比如checkpoint等日志数据.\n\n## 二、xlog记录写入\n","tags":["DBMS"],"categories":["PostgreSQL"]},{"title":"CentOS-7设置命令行显示PS1","url":"/652ad583bb6c/","content":"#### 修改当前用户下~/.bashrc\n\n```bash\nexport PS1=\"\\[\\e[33;1m\\]┌───\\[\\e[34;1m\\][\\[\\e[31;1m\\]\\u\\[\\e[34;1m\\]]-\\[\\e[34;1m\\][\\[\\e[32;1m\\]\\w\\[\\e[34;1m\\]]\\[\\e[33;1m\\]  \\t\\n\\[\\e[33;1m\\]└────☞\\$ \\[\\e[m\\]\"\n```\n<!-- more -->\n#### 执行命令\n\n```bash\nsource ~/.bashrc\n```\n\n#### 修改/etc/profile\n\n```bash\nexport PS1=\"\\[\\e[33;1m\\]┌───\\[\\e[34;1m\\][\\[\\e[31;1m\\]\\u\\[\\e[34;1m\\]]-\\[\\e[34;1m\\][\\[\\e[32;1m\\]\\w\\[\\e[34;1m\\]]\\[\\e[33;1m\\]  \\t\\n\\[\\e[33;1m\\]└────☞\\$ \\[\\e[m\\]\"\n```\n\n#### 修改root用户下~/.bashrc\n\n```bash\nsource /etc/profile\n```\n","tags":["CentOS"]},{"title":"检查链表的边界条件","url":"/040be08fc1bb/","content":"- 如果链表<font color=Darkorange>为空</font>时，代码是否能正常工作？\n- 如果链表<font color=Darkorange>只包含一个结点</font>时，代码是否能正常工作？\n- 如果链表<font color=Darkorange>只包含两个结点</font>时，代码是否能正常工作？\n- 代码逻辑在<font color=Darkorange>处理头结点和尾结点</font>的时候，是否能正常工作？\n","tags":["链表"],"categories":["算法"]},{"title":"gdb调试堆栈只显示问号","url":"/dc9302aa5d89/","content":"[程序挂了，GDB 调试只显示问号](https://blog.csdn.net/mseaspring/article/details/106346247)\n\n","tags":["gdb"]},{"title":"gdb常用命令","url":"/d50131e451e4/","content":"---\n\n```\n#psql查看当前窗口进程：select  pg_backend_pid();\n\n#gdb关联进程：gdb attach 进程号\n\n#gdb查看堆栈信息：bt\n```\n<!-- more -->\n---\n\n``` bash\n#1. 显示源代码窗口\n(gdb) layout src\n\n#2. 显示寄存器窗口\n(gdb) layout regs\n\n#3. 显示汇编代码窗口\n(gdb) layout asm\n\n#4. 显示源代码和汇编代码\n(gdb) layout split\n\n#5. 显示窗口的大小\ninfo win\n\n#6. 切换到下一个布局模式\nlayout next\n\n#7. 切换到上一个布局模式\nlayout prev\n\n#8. 切换当前窗口\nfocus cmd/src/asm/regs/next/prev\n\n#9. 刷新所有窗口\nrefresh\n\n#10. 更新源代码窗口和当前执行点\nupdate\n\n#11. 调整name窗口的高度\nwinheight name +/- line\n```\n\n---\n","tags":["gdb"]},{"title":"CentOS-7设置静态IP","url":"/302c5f2d176a/","content":"**1、修改ifcfg-ens33文件**\n``` sh\nvim /etc/sysconfig/network-scripts/ifcfg-ens33\n```\n<!-- more -->\n``` sh\nTYPE=Ethernet\nPROXY_METHOD=none\nBROWSER_ONLY=no\nBOOTPROTO=static\nDEFROUTE=yes\nIPV4_FAILURE_FATAL=no\nIPV6INIT=yes\nIPV6_AUTOCONF=yes\nIPV6_DEFROUTE=yes\nIPV6_FAILURE_FATAL=no\nIPV6_ADDR_GEN_MODE=stable-privacy\nNAME=ens33\nDEVICE=ens33\nONBOOT=yes\nIPADDR=192.168.1.128\nNETMASK=255.255.255.0\nGATEWAY=192.168.1.2\nDNS1=192.168.1.2\n```\n**2、重启network**\n```\nservice network restart\n```\n\n**3、设置静态IP脚本:setIP.sh**\n``` sh\n#!/bin/sh\n# 它的参数就是要设置的IP,如./setIP.sh 192.168.1.1\n\nFILE=\"/etc/sysconfig/network-scripts/ifcfg-ens33\"\nTEXT=\"TYPE=Ethernet\\n\\\nPROXY_METHOD=none\\n\\\nBROWSER_ONLY=no\\n\\\nBOOTPROTO=static\\n\\\nDEFROUTE=yes\\n\\\nIPV4_FAILURE_FATAL=no\\n\\\nIPV6INIT=yes\\n\\\nIPV6_AUTOCONF=yes\\n\\\nIPV6_DEFROUTE=yes\\n\\\nIPV6_FAILURE_FATAL=no\\n\\\nIPV6_ADDR_GEN_MODE=stable-privacy\\n\\\nNAME=ens33\\n\\\nDEVICE=ens33\\n\\\nONBOOT=yes\\n\\\nIPADDR=192.168.119.150\\n\\\nNETMASK=255.255.255.0\\n\\\nGATEWAY=192.168.119.2\\n\\\nDNS1=192.168.119.2\"\n\nIPADDR=\"IPPADDR=$1\"\n\n\nIPADDR=$1\n_ckIPaddr () {\n        ckStep1=`echo $1 | awk -F\".\" '{print NF}'`\n        if [ $ckStep1 -eq 4 ] || [ $ckStep1 -eq 6 ]\n        then\n                ckStep2=`echo $1 | awk -F\".\" '{if ($1!=0 && $NF!=0) split ($0,IPNUM,\".\")} END \\\n        { for (k in IPNUM) if (IPNUM[k]==0) print IPNUM[k]; else if (IPNUM[k]!=0 && IPNUM[k]!~/[a-z|A-Z]/ && length(IPNUM[k])<=3 &&\nIPNUM[k]<255 && IPNUM[k]!~/^0/) print IPNUM[k]}'| wc -l`\n                if [ $ckStep2 -eq $ckStep1 ]\n                then\n                        echo 0\n                else\n                        echo 1\n                fi\n        else\n                echo 1\n        fi\n}\n \nCK_IPADDR=`_ckIPaddr $IPADDR`\n\nif [ $CK_IPADDR -eq 1 ]\nthen\n\n     echo \"The string $IPADDR is not a correct ipaddr!!!\"\n     exit 1\nfi\n\necho \"\"  > $FILE\n\n\necho -e $TEXT > $FILE\n\nIPADDRSTR=\"IPADDR=\"$IPADDR\necho -e $IPADDRSTR >> $FILE\n\necho \"NETMASK=255.255.255.0\" >> $FILE\n\nGATEWAY=\"GATEWAY=\"\nDNS1=\"DNS1=\"\n\nsum=0\nIPADDR=${IPADDR//./ }    \nfor element in $IPADDR\ndo\n    let \"sum++\"\n    if [ $sum -ge 4 ];then\n        break\n    fi\n\n    GATEWAY=$GATEWAY$element\".\"\n    DNS1=$DNS1$element\".\"    \ndone\n\nGATEWAY=$GATEWAY\"2\"\nDNS1=$DNS1\"2\"\n\necho -e $GATEWAY >> $FILE\necho -e $DNS1 >> $FILE\n\nservice network restart\n```\n","tags":["CentOS"]},{"title":"CentOS-7设置Samba共享目录","url":"/878ab92a9d81/","content":"**1.安装Samba服务**\n```bash\n# 下载安装Samba\nyum -y install samba\n# 查看yum源中Samba版本\nyum list | grep samba\n# 查看samba的安装情况\nrpm -qa | grep samba\n```\n<!-- more -->\n\n**2. 启动Samba服务**\n```bash\n# Samba服务安装完成之后有两种方法启动:\nservice smb start\n# 或者\nsystemctl start smb.service\n```\n\n```bash\n# 设置smb服务开机启动\nsystemctl enable smb.service\n```\n\n**3. 关闭防火墙**\n```bash\n# 执行关闭命令：\nsystemctl stop firewalld.service\n\n# 执行开机禁用防火墙自启命令：\nsystemctl disable firewalld.service\n```\n\n**4.修改Samba配置**\n```vim\n/*** vim /etc/samba/smb.conf\n *** 其中[CentOS]下的path要修改为共享的目录 ***/\n[global]\nworkgroup = MYGROUP\nserver string = Samba Server Version %v\nlog file = /var/log/samba/log.%m\nmax log size = 50\nsecurity = user\npassdb backend = tdbsam\nload printers = yes\ncups options = raw\n\n[printers]\ncomment = All Printers\npath = /var/spool/samba\nbrowseable = no\nguest ok = no\nwritable = no\nprintable = yes\n\n[CentOS]\ncomment = myshare\nbrowseable = yes\npath = /home/share\nwritable = yes\n```\n\n**5.将访问的账户添加到samba的账户中**\n```\nsmbpasswd 命令参数:\n\t-a: 添加\n\t-x: 删除 \n\t-d: 禁用 \n\t-e: 启用\nsmbpasswd -a 系统用户名\n```\n\n**6.确保 setlinux 关闭**\n```bash\n setenforce 0\n```\n\n**7.重启samba服务**\n```bash\nservice smb restart\n```\n\n","tags":["CentOS"]}]