[{"title":"CentOS-7设置Samba共享目录","url":"/878ab92a9d81/","content":"<p><strong>1.安装Samba服务</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载安装Samba</span></span><br><span class=\"line\">yum -y install samba</span><br><span class=\"line\"><span class=\"comment\"># 查看yum源中Samba版本</span></span><br><span class=\"line\">yum list | grep samba</span><br><span class=\"line\"><span class=\"comment\"># 查看samba的安装情况</span></span><br><span class=\"line\">rpm -qa | grep samba</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<p><strong>2. 启动Samba服务</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Samba服务安装完成之后有两种方法启动:</span></span><br><span class=\"line\">service smb start</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">systemctl start smb.service</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置smb服务开机启动</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> smb.service</span><br></pre></td></tr></table></figure>\n<p><strong>3. 关闭防火墙</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 执行关闭命令：</span></span><br><span class=\"line\">systemctl stop firewalld.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行开机禁用防火墙自启命令：</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> firewalld.service</span><br></pre></td></tr></table></figure>\n<p><strong>4.修改Samba配置</strong></p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*** <span class=\"keyword\">vim</span> /etc/samba/smb.<span class=\"keyword\">conf</span></span><br><span class=\"line\"> *** 其中[CentOS]下的path要修改为共享的目录 ***/</span><br><span class=\"line\">[<span class=\"keyword\">global</span>]</span><br><span class=\"line\">workgroup = MYGROUP</span><br><span class=\"line\">server <span class=\"built_in\">string</span> = Samba Server Version %v</span><br><span class=\"line\"><span class=\"built_in\">log</span> <span class=\"keyword\">file</span> = /var/<span class=\"built_in\">log</span>/samba/<span class=\"built_in\">log</span>.%<span class=\"keyword\">m</span></span><br><span class=\"line\"><span class=\"built_in\">max</span> <span class=\"built_in\">log</span> size = <span class=\"number\">50</span></span><br><span class=\"line\">security = user</span><br><span class=\"line\">passdb backend = tdbsam</span><br><span class=\"line\">load printers = yes</span><br><span class=\"line\">cups <span class=\"keyword\">options</span> = raw</span><br><span class=\"line\"></span><br><span class=\"line\">[printers]</span><br><span class=\"line\">comment = All Printers</span><br><span class=\"line\">path = /var/spool/samba</span><br><span class=\"line\">browseable = <span class=\"keyword\">no</span></span><br><span class=\"line\">guest ok = <span class=\"keyword\">no</span></span><br><span class=\"line\">writable = <span class=\"keyword\">no</span></span><br><span class=\"line\">printable = yes</span><br><span class=\"line\"></span><br><span class=\"line\">[CentOS]</span><br><span class=\"line\">comment = myshare</span><br><span class=\"line\">browseable = yes</span><br><span class=\"line\">path = /home/share</span><br><span class=\"line\">writable = yes</span><br></pre></td></tr></table></figure>\n<p><strong>5.将访问的账户添加到samba的账户中</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">smbpasswd 命令参数:</span><br><span class=\"line\">\t-a: 添加</span><br><span class=\"line\">\t-x: 删除 </span><br><span class=\"line\">\t-d: 禁用 </span><br><span class=\"line\">\t-e: 启用</span><br><span class=\"line\">smbpasswd -a 系统用户名</span><br></pre></td></tr></table></figure>\n<p><strong>6.确保 setlinux 关闭</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">setenforce 0</span><br></pre></td></tr></table></figure>\n<p><strong>7.重启samba服务</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">service smb restart</span><br></pre></td></tr></table></figure>\n","tags":["CentOS"]},{"title":"CentOS-7设置命令行显示PS1","url":"/652ad583bb6c/","content":"<h4 id=\"修改当前用户下-bashrc\">修改当前用户下~/.bashrc</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> PS1=<span class=\"string\">&quot;\\[\\e[33;1m\\]┌───\\[\\e[34;1m\\][\\[\\e[31;1m\\]\\u\\[\\e[34;1m\\]]-\\[\\e[34;1m\\][\\[\\e[32;1m\\]\\w\\[\\e[34;1m\\]]\\[\\e[33;1m\\]  \\t\\n\\[\\e[33;1m\\]└────☞\\$ \\[\\e[m\\]&quot;</span></span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<h4 id=\"执行命令\">执行命令</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改-etc-profile\">修改/etc/profile</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> PS1=<span class=\"string\">&quot;\\[\\e[33;1m\\]┌───\\[\\e[34;1m\\][\\[\\e[31;1m\\]\\u\\[\\e[34;1m\\]]-\\[\\e[34;1m\\][\\[\\e[32;1m\\]\\w\\[\\e[34;1m\\]]\\[\\e[33;1m\\]  \\t\\n\\[\\e[33;1m\\]└────☞\\$ \\[\\e[m\\]&quot;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"修改root用户下-bashrc\">修改root用户下~/.bashrc</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile</span><br></pre></td></tr></table></figure>\n","tags":["CentOS"]},{"title":"CentOS-7设置静态IP","url":"/302c5f2d176a/","content":"<p><strong>1、修改ifcfg-ens33文件</strong></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">TYPE=Ethernet</span><br><span class=\"line\">PROXY_METHOD=none</span><br><span class=\"line\">BROWSER_ONLY=no</span><br><span class=\"line\">BOOTPROTO=static</span><br><span class=\"line\">DEFROUTE=<span class=\"built_in\">yes</span></span><br><span class=\"line\">IPV4_FAILURE_FATAL=no</span><br><span class=\"line\">IPV6INIT=<span class=\"built_in\">yes</span></span><br><span class=\"line\">IPV6_AUTOCONF=<span class=\"built_in\">yes</span></span><br><span class=\"line\">IPV6_DEFROUTE=<span class=\"built_in\">yes</span></span><br><span class=\"line\">IPV6_FAILURE_FATAL=no</span><br><span class=\"line\">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class=\"line\">NAME=ens33</span><br><span class=\"line\">DEVICE=ens33</span><br><span class=\"line\">ONBOOT=<span class=\"built_in\">yes</span></span><br><span class=\"line\">IPADDR=192.168.1.128</span><br><span class=\"line\">NETMASK=255.255.255.0</span><br><span class=\"line\">GATEWAY=192.168.1.2</span><br><span class=\"line\">DNS1=192.168.1.2</span><br></pre></td></tr></table></figure>\n<p><strong>2、重启network</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">service network restart</span><br></pre></td></tr></table></figure>\n<p><strong>3、设置静态IP脚本:setIP.sh</strong></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"comment\"># 它的参数就是要设置的IP,如./setIP.sh 192.168.1.1</span></span><br><span class=\"line\"></span><br><span class=\"line\">FILE=<span class=\"string\">&quot;/etc/sysconfig/network-scripts/ifcfg-ens33&quot;</span></span><br><span class=\"line\">TEXT=<span class=\"string\">&quot;TYPE=Ethernet\\n\\</span></span><br><span class=\"line\"><span class=\"string\">PROXY_METHOD=none\\n\\</span></span><br><span class=\"line\"><span class=\"string\">BROWSER_ONLY=no\\n\\</span></span><br><span class=\"line\"><span class=\"string\">BOOTPROTO=static\\n\\</span></span><br><span class=\"line\"><span class=\"string\">DEFROUTE=yes\\n\\</span></span><br><span class=\"line\"><span class=\"string\">IPV4_FAILURE_FATAL=no\\n\\</span></span><br><span class=\"line\"><span class=\"string\">IPV6INIT=yes\\n\\</span></span><br><span class=\"line\"><span class=\"string\">IPV6_AUTOCONF=yes\\n\\</span></span><br><span class=\"line\"><span class=\"string\">IPV6_DEFROUTE=yes\\n\\</span></span><br><span class=\"line\"><span class=\"string\">IPV6_FAILURE_FATAL=no\\n\\</span></span><br><span class=\"line\"><span class=\"string\">IPV6_ADDR_GEN_MODE=stable-privacy\\n\\</span></span><br><span class=\"line\"><span class=\"string\">NAME=ens33\\n\\</span></span><br><span class=\"line\"><span class=\"string\">DEVICE=ens33\\n\\</span></span><br><span class=\"line\"><span class=\"string\">ONBOOT=yes\\n\\</span></span><br><span class=\"line\"><span class=\"string\">IPADDR=192.168.119.150\\n\\</span></span><br><span class=\"line\"><span class=\"string\">NETMASK=255.255.255.0\\n\\</span></span><br><span class=\"line\"><span class=\"string\">GATEWAY=192.168.119.2\\n\\</span></span><br><span class=\"line\"><span class=\"string\">DNS1=192.168.119.2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">IPADDR=<span class=\"string\">&quot;IPPADDR=<span class=\"variable\">$1</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">IPADDR=<span class=\"variable\">$1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">_ckIPaddr</span></span> () &#123;</span><br><span class=\"line\">        ckStep1=`<span class=\"built_in\">echo</span> <span class=\"variable\">$1</span> | awk -F<span class=\"string\">&quot;.&quot;</span> <span class=\"string\">&#x27;&#123;print NF&#125;&#x27;</span>`</span><br><span class=\"line\">        <span class=\"keyword\">if</span> [ <span class=\"variable\">$ckStep1</span> -eq 4 ] || [ <span class=\"variable\">$ckStep1</span> -eq 6 ]</span><br><span class=\"line\">        <span class=\"keyword\">then</span></span><br><span class=\"line\">                ckStep2=`<span class=\"built_in\">echo</span> <span class=\"variable\">$1</span> | awk -F<span class=\"string\">&quot;.&quot;</span> <span class=\"string\">&#x27;&#123;if ($1!=0 &amp;&amp; $NF!=0) split ($0,IPNUM,&quot;.&quot;)&#125; END \\</span></span><br><span class=\"line\"><span class=\"string\">        &#123; for (k in IPNUM) if (IPNUM[k]==0) print IPNUM[k]; else if (IPNUM[k]!=0 &amp;&amp; IPNUM[k]!~/[a-z|A-Z]/ &amp;&amp; length(IPNUM[k])&lt;=3 &amp;&amp;</span></span><br><span class=\"line\"><span class=\"string\">IPNUM[k]&lt;255 &amp;&amp; IPNUM[k]!~/^0/) print IPNUM[k]&#125;&#x27;</span>| <span class=\"built_in\">wc</span> -l`</span><br><span class=\"line\">                <span class=\"keyword\">if</span> [ <span class=\"variable\">$ckStep2</span> -eq <span class=\"variable\">$ckStep1</span> ]</span><br><span class=\"line\">                <span class=\"keyword\">then</span></span><br><span class=\"line\">                        <span class=\"built_in\">echo</span> 0</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                        <span class=\"built_in\">echo</span> 1</span><br><span class=\"line\">                <span class=\"keyword\">fi</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"built_in\">echo</span> 1</span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">CK_IPADDR=`_ckIPaddr <span class=\"variable\">$IPADDR</span>`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$CK_IPADDR</span> -eq 1 ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"built_in\">echo</span> <span class=\"string\">&quot;The string <span class=\"variable\">$IPADDR</span> is not a correct ipaddr!!!&quot;</span></span><br><span class=\"line\">     <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;&quot;</span>  &gt; <span class=\"variable\">$FILE</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"variable\">$TEXT</span> &gt; <span class=\"variable\">$FILE</span></span><br><span class=\"line\"></span><br><span class=\"line\">IPADDRSTR=<span class=\"string\">&quot;IPADDR=&quot;</span><span class=\"variable\">$IPADDR</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"variable\">$IPADDRSTR</span> &gt;&gt; <span class=\"variable\">$FILE</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;NETMASK=255.255.255.0&quot;</span> &gt;&gt; <span class=\"variable\">$FILE</span></span><br><span class=\"line\"></span><br><span class=\"line\">GATEWAY=<span class=\"string\">&quot;GATEWAY=&quot;</span></span><br><span class=\"line\">DNS1=<span class=\"string\">&quot;DNS1=&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">sum</span>=0</span><br><span class=\"line\">IPADDR=<span class=\"variable\">$&#123;IPADDR//./ &#125;</span>    </span><br><span class=\"line\"><span class=\"keyword\">for</span> element <span class=\"keyword\">in</span> <span class=\"variable\">$IPADDR</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">let</span> <span class=\"string\">&quot;sum++&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"variable\">$sum</span> -ge 4 ];<span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">    GATEWAY=$GATEWAY<span class=\"variable\">$element</span><span class=\"string\">&quot;.&quot;</span></span><br><span class=\"line\">    DNS1=$DNS1<span class=\"variable\">$element</span><span class=\"string\">&quot;.&quot;</span>    </span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\">GATEWAY=<span class=\"variable\">$GATEWAY</span><span class=\"string\">&quot;2&quot;</span></span><br><span class=\"line\">DNS1=<span class=\"variable\">$DNS1</span><span class=\"string\">&quot;2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"variable\">$GATEWAY</span> &gt;&gt; <span class=\"variable\">$FILE</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"variable\">$DNS1</span> &gt;&gt; <span class=\"variable\">$FILE</span></span><br><span class=\"line\"></span><br><span class=\"line\">service network restart</span><br></pre></td></tr></table></figure>\n","tags":["CentOS"]},{"title":"C函数在调用return退出时出现段错误的可能原因","url":"/cfcb83679091/","content":"<p>  可能性最大的在当前调用函数的文件中未引入头文件，导致截断（有的系统默认指针是 4 个<br>\n字节，64 位系统指针是 8 个字节，但是在函数未定义的情况下，系统默认回传 4 个字节的指针，<br>\n就会导致指针高 4 位未被回传，系统就会默认会将高 4 位填充成 FFFF，导致指针地址出错），<br>\n出现的段错误。</p>\n","tags":["gdb"]},{"title":"PostgreSQL-并发控制","url":"/13ddc1c017f3/","content":"<h2 id=\"一、事务标识\">一、事务标识</h2>\n<p>当事务开始时，事务管理器会为其分配一个事务标识（txid）的唯一标识符。</p>\n<p>PostgreSQL有三个特殊txid:</p>\n<ul>\n<li>0标识无效的txid；</li>\n<li>1表示初始启动的txid，仅用于数据库集群的初始化过程；</li>\n<li>2表示冻结的txid。</li>\n</ul>\n<span id=\"more\"></span>\n<p>txid在逻辑上是无限的，但实际系统的txid空间不足（4B整型的取值空间大小约42亿），因此Postgresql将txid空间视为一个环。对于某个txid，其前21亿个txid属于过去，其后约21亿个txid属于未来。</p>\n<h2 id=\"二、元组结构\">二、元组结构</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapTupleFields</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tTransactionId t_xmin;\t\t<span class=\"comment\">/* inserting xact ID; 插入事务的ID */</span></span><br><span class=\"line\">\tTransactionId t_xmax;\t\t<span class=\"comment\">/* deleting or locking xact ID; 删除或锁定事务的ID */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">\t&#123;</span></span><br><span class=\"line\">\t\tCommandId\tt_cid;\t\t<span class=\"comment\">/* inserting or deleting command ID, or both; 插入或删除的命令ID */</span></span><br><span class=\"line\">\t\tTransactionId t_xvac;\t<span class=\"comment\">/* old-style VACUUM FULL xact ID; 老式VACUUM FULL的事务ID */</span></span><br><span class=\"line\">\t&#125;\t\t\tt_field3;</span><br><span class=\"line\">&#125; HeapTupleFields;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapTupleHeaderData</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">\t&#123;</span></span><br><span class=\"line\">\t\tHeapTupleFields t_heap;</span><br><span class=\"line\">\t\tDatumTupleFields t_datum;</span><br><span class=\"line\">\t&#125;\t\t\tt_choice;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//当前元组或更新元组的TID</span></span><br><span class=\"line\">\tItemPointerData t_ctid;\t\t<span class=\"comment\">/* current TID of this or newer tuple (or a</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t * speculative insertion token) */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Fields below here must match MinimalTupleData! */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK2 2</span></span><br><span class=\"line\">\tuint16\t\tt_infomask2;\t<span class=\"comment\">/* number of attributes + various flags */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK 3</span></span><br><span class=\"line\">\tuint16\t\tt_infomask;\t\t<span class=\"comment\">/* various flag bits, see below */</span> <span class=\"comment\">//主要保存了事务的状态标记位</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FIELDNO_HEAPTUPLEHEADERDATA_HOFF 4</span></span><br><span class=\"line\">\tuint8\t\tt_hoff;\t\t\t<span class=\"comment\">/* sizeof header incl. bitmap, padding */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* ^ - 23 bytes - ^ */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FIELDNO_HEAPTUPLEHEADERDATA_BITS 5</span></span><br><span class=\"line\">\tbits8\t\tt_bits[FLEXIBLE_ARRAY_MEMBER];\t<span class=\"comment\">/* bitmap of NULLs */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* MORE DATA FOLLOWS AT END OF STRUCT */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<hr>\n<p><img data-src=\"/images/tuple.png\" alt=\"\"></p>\n<p>t_xmin：代表插入此元组的事务xid；</p>\n<p>t_xmax：代表更新或者删除此元组的事务xid，如果该元组插入后未进行更新或者删除，t_xmax=0；</p>\n<p>t_cid：command id，代表在当前事务中，已经执行过多少条sql，例如执行第一条sql时cid=0，执行第二条sql时cid=1；</p>\n<p>t_ctid：保存着指向自身或者新元组的元组标识（tid），由两个数字组成，第一个数字代表物理块号，或者叫页面号，第二个数字代表元组号。在元组更新后tid指向新版本的元组，否则指向自己，这样其实就形成了新旧元组之间的“元组链”，这个链在元组查找和定位上起着重要作用。</p>\n<h2 id=\"三、元组的增、删、改\">三、元组的增、删、改</h2>\n<h3 id=\"1、更新元组\">1、更新元组</h3>\n<p><img data-src=\"/images/tuple_update.png\" alt=\"\"></p>\n<p>左图是一条新插入的元组，可以看到元组是xid=100的事务插入的，没有进行更新，所以t_xmax=0，同时t_ctid指向自己，0号页面的第一号元组。<br>\n右图是发生xid=101的事务更新该元组后的状态，更新在pg里相当于插入一条新元组，原来的元组的t_xmax变为了更新这条事务的xid=101，同时t_ctid指针指向了新插入的元组（0,2），0号页面第二号元组，第二号元组的t_xmin=101（插入该元组的xid），t_ctid=（0,2），没有发生更新，指向自己。</p>\n<h3 id=\"2、删除元组\">2、删除元组</h3>\n<p><img data-src=\"/images/tuple_delete.png\" alt=\"\"></p>\n<p>上图代表该元组被xid=102的事务删除，将t_xmax设置为删除事务的xid，t_ctid指向自己。</p>\n<h2 id=\"四、提交日志（clog）\">四、提交日志（clog）</h2>\n<p>Postgresql在提交日志（CLOG）中保存事务的状态。CLOG分配于共享内存中，并用于事务处理过程的全过程。</p>\n<p>每次事务提交和回滚的时候，都需要更新该状态（调用CommitTransactionCommand(void)），PostgreSQL服务器访问该文件确定事务的状态，保存在pg_xact目录中，每个文件大小为256KB，每个事务2位（bit），故1个文件可以包含131072个事务。对于第一次修改的数据行来说，因为事务状态存储在clog中，所以修改后第一次判断行的可见性需要通过访问clog来确定，而访问clog是一个非常耗费性能的过程，</p>\n<h3 id=\"1、事务状态\">1、事务状态</h3>\n<ul>\n<li>IN_PROGRESS</li>\n<li>COMMITTED</li>\n<li>ABORTED</li>\n<li>SUB_COMMITTED</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Possible transaction statuses --- note that all-zeroes is the initial</span></span><br><span class=\"line\"><span class=\"comment\"> * state.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * A &quot;subcommitted&quot; transaction is a committed subtransaction whose parent</span></span><br><span class=\"line\"><span class=\"comment\"> * hasn&#x27;t committed or aborted yet.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> XidStatus;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TRANSACTION_STATUS_IN_PROGRESS\t\t0x00</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TRANSACTION_STATUS_COMMITTED\t\t0x01</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TRANSACTION_STATUS_ABORTED\t\t\t0x02</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TRANSACTION_STATUS_SUB_COMMITTED\t0x03</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2、事务特性\">2、事务特性</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* We need two bits per xact, so four xacts fit in a byte */</span></span><br><span class=\"line\"><span class=\"comment\">/* pg中通过2个bit位来标识4种事务状态(0、1、2、3)，那么1个字节便可以存储4个事务，对于1个8k的page则可以存储8k * 4 = 32k个事务。 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CLOG_BITS_PER_XACT\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CLOG_XACTS_PER_BYTE 4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CLOG_XACTS_PER_PAGE (BLCKSZ * CLOG_XACTS_PER_BYTE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CLOG_XACT_BITMASK\t((1 &lt;&lt; CLOG_BITS_PER_XACT) - 1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TransactionIdToPage(xid)\t((xid) / (TransactionId) CLOG_XACTS_PER_PAGE)  <span class=\"comment\">// 通过xid获取页</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TransactionIdToPgIndex(xid) ((xid) % (TransactionId) CLOG_XACTS_PER_PAGE)  <span class=\"comment\">// 获取xid在页中的索引</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TransactionIdToByte(xid)\t(TransactionIdToPgIndex(xid) / CLOG_XACTS_PER_BYTE)  <span class=\"comment\">// 获取xid在页中的位置（第几个字节）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TransactionIdToBIndex(xid)\t((xid) % (TransactionId) CLOG_XACTS_PER_BYTE) <span class=\"comment\">// 获取xid在页中的位置（在某个字节中位于第几个事务）</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>事务id并不是在事务开始时就会被分配，而是当事务进行了数据修改之类的操作时才会分配xid，而当事务提交或回滚时，其事务状态便会被写入clog中。</p>\n</li>\n<li>\n<p>前一个事务所有修改的数据，它没有在提交或者回滚的当时改掉所有的修改标记，而是等到下次查询时进行修改（为了提升性能）。</p>\n</li>\n</ul>\n<h2 id=\"五、事务快照\">五、事务快照</h2>\n<h3 id=\"1、快照定义\">1、快照定义</h3>\n<p>事务快照在postgresql中的文本表示格式为xmin:xmax:xip_list。100:100：意味着txid &lt; 100的事务处于非活跃状态，而txid ≥ 100的事务处于活跃状态。</p>\n<p><img data-src=\"/images/snapshot.png\" alt=\"\"></p>\n<p><strong>100:100：含义如下</strong></p>\n<ul>\n<li>xmin=100，所以txid&lt;100的事务均不活跃</li>\n<li>xmax=100，所以txid&gt;=100的事务均活跃或未启动</li>\n<li>xip_list为空，表示[xmin,xmax)范围内无活跃事务</li>\n</ul>\n<p><strong>100:104:100,102含义如下</strong></p>\n<ul>\n<li>xmin=100，所以txid&lt;100的事务均不活跃</li>\n<li>xmax=104，所以txid&gt;=104的事务均活跃或未启动</li>\n<li>xip_list为100,102，表示[xmin,xmax)范围内100,102为活跃事务</li>\n</ul>\n<h3 id=\"2、快照与隔离级别\">2、快照与隔离级别</h3>\n<p>pg会根据不同隔离级别设置，获取不同时刻的快照：</p>\n<ul>\n<li><strong>已提交读：在该事务的每条SQL执行之前都会重新获取一次快照</strong></li>\n<li><strong>可重复读和可串行化：该事务只在第一条SQL执行之前获取一次快照</strong></li>\n</ul>\n<p><img data-src=\"/images/snapshot_trans.png\" alt=\"\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 快照相关的数据结构</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SnapshotData</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tSnapshotType snapshot_type; <span class=\"comment\">/* type of snapshot; 事务类型 */</span> </span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * The remaining fields are used only for MVCC snapshots, and are normally</span></span><br><span class=\"line\"><span class=\"comment\">\t * just zeroes in special snapshots.  (But xmin and xmax are used</span></span><br><span class=\"line\"><span class=\"comment\">\t * specially by HeapTupleSatisfiesDirty, and xmin is used specially by</span></span><br><span class=\"line\"><span class=\"comment\">\t * HeapTupleSatisfiesNonVacuumable.)</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * An MVCC snapshot can never see the effects of XIDs &gt;= xmax. It can see</span></span><br><span class=\"line\"><span class=\"comment\">\t * the effects of all older XIDs except those listed in the snapshot. xmin</span></span><br><span class=\"line\"><span class=\"comment\">\t * is stored as an optimization to avoid needing to search the XID arrays</span></span><br><span class=\"line\"><span class=\"comment\">\t * for most tuples.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tTransactionId xmin;\t\t\t<span class=\"comment\">/* all XID &lt; xmin are visible to me; 若事务ID小于xmin，则对当前事务可见 */</span></span><br><span class=\"line\">\tTransactionId xmax;\t\t\t<span class=\"comment\">/* all XID &gt;= xmax are invisible to me; 若事务ID大于xmax，则对当前事务不可见 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * For normal MVCC snapshot this contains the all xact IDs that are in</span></span><br><span class=\"line\"><span class=\"comment\">\t * progress, unless the snapshot was taken during recovery in which case</span></span><br><span class=\"line\"><span class=\"comment\">\t * it&#x27;s empty. For historic MVCC snapshots, the meaning is inverted, i.e.</span></span><br><span class=\"line\"><span class=\"comment\">\t * it contains *committed* transactions between xmin and xmax.</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * note: all ids in xip[] satisfy xmin &lt;= xip[i] &lt; xmax</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tTransactionId *xip;  <span class=\"comment\">//  快照生成时对应的活跃事务列表</span></span><br><span class=\"line\">\tuint32\t\txcnt;\t\t\t<span class=\"comment\">/* # of xact ids in xip[]; xip数组大小 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * For non-historic MVCC snapshots, this contains subxact IDs that are in</span></span><br><span class=\"line\"><span class=\"comment\">\t * progress (and other transactions that are in progress if taken during</span></span><br><span class=\"line\"><span class=\"comment\">\t * recovery). For historic snapshot it contains *all* xids assigned to the</span></span><br><span class=\"line\"><span class=\"comment\">\t * replayed transaction, including the toplevel xid.</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * note: all ids in subxip[] are &gt;= xmin, but we don&#x27;t bother filtering</span></span><br><span class=\"line\"><span class=\"comment\">\t * out any that are &gt;= xmax</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tTransactionId *subxip; <span class=\"comment\">// 活跃的子事务列表</span></span><br><span class=\"line\">\tint32\t\tsubxcnt;\t\t<span class=\"comment\">/* # of xact ids in subxip[]; sub xip数组大小 */</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span>\t\tsuboverflowed;\t<span class=\"comment\">/* has the subxip array overflowed? ;当子事务过多时，数组有可能overflow */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">bool</span>\t\ttakenDuringRecovery;\t<span class=\"comment\">/* recovery-shaped snapshot? */</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span>\t\tcopied;\t\t\t<span class=\"comment\">/* false if it&#x27;s a static snapshot; 如果是静态快照则为false */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tCommandId\tcurcid;\t\t\t<span class=\"comment\">/* in my xact, CID &lt; curcid are visible */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * An extra return value for HeapTupleSatisfiesDirty, not used in MVCC</span></span><br><span class=\"line\"><span class=\"comment\">\t * snapshots.</span></span><br><span class=\"line\"><span class=\"comment\">\t * </span></span><br><span class=\"line\"><span class=\"comment\">\t * HeapTupleSatisfiesDirty使用的一个变量，在判断可见性的同时，会借助这</span></span><br><span class=\"line\"><span class=\"comment\">\t * 个变量将元组上的speculativeToken返回给上层</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tuint32\t\tspeculativeToken;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * For SNAPSHOT_NON_VACUUMABLE (and hopefully more in the future) this is</span></span><br><span class=\"line\"><span class=\"comment\">\t * used to determine whether row could be vacuumed.</span></span><br><span class=\"line\"><span class=\"comment\">     * 元组是否可vacuum（用于SNAPSHOT_NON_VACUUMABLE状态）</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GlobalVisState</span> *<span class=\"title\">vistest</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Book-keeping information, used by the snapshot manager</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tuint32\t\tactive_count;\t<span class=\"comment\">/* refcount on ActiveSnapshot stack */</span></span><br><span class=\"line\">\tuint32\t\tregd_count;\t\t<span class=\"comment\">/* refcount on RegisteredSnapshots */</span></span><br><span class=\"line\">\tpairingheap_node ph_node;\t<span class=\"comment\">/* link in the RegisteredSnapshots heap */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tTimestampTz whenTaken;\t\t<span class=\"comment\">/* timestamp when snapshot was taken */</span></span><br><span class=\"line\">\tXLogRecPtr\tlsn;\t\t\t<span class=\"comment\">/* position in the WAL stream when taken */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * The transaction completion count at the time GetSnapshotData() built</span></span><br><span class=\"line\"><span class=\"comment\">\t * this snapshot. Allows to avoid re-computing static snapshots when no</span></span><br><span class=\"line\"><span class=\"comment\">\t * transactions completed since the last GetSnapshotData().</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tuint64\t\tsnapXactCompletionCount;</span><br><span class=\"line\">&#125; SnapshotData;</span><br></pre></td></tr></table></figure>\n<h2 id=\"六、可见性检查\">六、可见性检查</h2>\n<p><strong>事务并发可能出现的现象：</strong></p>\n<ul>\n<li>\n<p>脏读：某一事务读取了另一个事务未提交的脏数据。</p>\n</li>\n<li>\n<p>幻读：读取了前一事务提交的数据（针对的是一批数据整体，比如数据的个数 ）。</p>\n</li>\n<li>\n<p>不可重复读：读取了前一事务提交的数据（查询的都是 同一个数据项 ）。</p>\n</li>\n</ul>\n<p><strong>事务隔离级别：</strong></p>\n<ul>\n<li>READ UNCOMMITTED（读未提交）------ postgresql不存在这个隔离级别，所以不会出现脏读的现象。</li>\n<li>READ COMMITTED（读已提交）------ 可能会发生幻读和不可重复读。</li>\n<li>REPEATABLE READ（可重复读）------ 不会发生幻读和不可重复读（标准sql事务隔离级别允许幻读）。</li>\n<li>SERIALIZABLE（序列化）------ 不会发生幻读和不可重复读。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读未提交</td>\n<td>可能</td>\n<td>可能</td>\n<td>可能</td>\n</tr>\n<tr>\n<td>读已提交</td>\n<td>不可能</td>\n<td>可能</td>\n<td>可能</td>\n</tr>\n<tr>\n<td>可重复读</td>\n<td>不可能</td>\n<td>不可能</td>\n<td>Allowed, but not in PG</td>\n</tr>\n<tr>\n<td>可串行化</td>\n<td>不可能</td>\n<td>不可能</td>\n<td>不可能</td>\n</tr>\n</tbody>\n</table>\n<p><strong>元组的可见性:</strong></p>\n<p>确定一条元组是否对一个事务可见，可见性检查规则会用到元组的t_xmin和t_xmax,提交日志ClOG，以及已获取的事务快照。</p>\n<p>t_xmin状态为 ABORTED的元组始终不可见</p>\n<p>t_xmin状态为IN_PROGRESS的元组基本上是不可见的（对自身事务可见）</p>\n<p>t_xmin状态为COMMITTED的元组是可见的</p>\n","categories":["PostgreSQL"],"tags":["DBMS"]},{"title":"PostgreSQL-bufmmgr","url":"/b17ff0458240/","content":"<h2 id=\"一、-缓冲区管理器的结构\">一、 缓冲区管理器的结构</h2>\n<p>PostgreSQL缓冲区管理器由三层组成，即<strong>缓冲表层</strong>，<strong>缓冲区描述符层</strong>和<strong>缓冲池层</strong></p>\n<span id=\"more\"></span>\n<p><img data-src=\"/images/bufmgr.png\" alt=\"\"></p>\n<ul>\n<li>**缓冲表（buffer table）**层是一个哈希表，它存储着页面的<code>buffer_tag</code>与描述符的<code>buffer_id</code>之间的映射关系。</li>\n<li>**缓冲区描述符（buffer descriptors）**层是一个由缓冲区描述符组成的数组。 每个描述符与缓冲池槽一一对应，并保存着相应槽的元数据。</li>\n<li>**缓冲池（buffer pool）**层是一个数组。 每个槽都存储一个数据文件页，数组槽的索引称为<code>buffer_id</code>。</li>\n</ul>\n<h3 id=\"1、缓冲表\">1、缓冲表</h3>\n<p>缓冲表分为三个部分：散列函数（hash function）、散列桶槽（buckets slots）、数据项（data entries）。</p>\n<p>内置散列函数将buffer_tag映射到哈希桶槽。可能会发生冲突，采用了使用链表的分离链接方法来解决冲突。</p>\n<p><img data-src=\"/images/buffer_table.png\" alt=\"\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">RelFileNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tOid\t\t\tspcNode;\t\t<span class=\"comment\">/* tablespace */</span></span><br><span class=\"line\">\tOid\t\t\tdbNode;\t\t\t<span class=\"comment\">/* database */</span></span><br><span class=\"line\">\tOid\t\t\trelNode;\t\t<span class=\"comment\">/* relation */</span></span><br><span class=\"line\">&#125; RelFileNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* buftag对应的数据结构 */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buftag</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tRelFileNode rnode;\t\t<span class=\"comment\">/* physical relation identifier */</span></span><br><span class=\"line\">\tForkNumber\tforkNum;        <span class=\"comment\">/* 关系的分支编号 */</span></span><br><span class=\"line\">\tBlockNumber blockNum;\t\t<span class=\"comment\">/* blknum relative to begin of reln */</span></span><br><span class=\"line\">&#125; BufferTag;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、缓冲区描述符\">2、缓冲区描述符</h3>\n<p>缓冲区描述符保存着页面的元数据，这些与缓冲区描述符对应的页面保存在缓冲池槽中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 缓冲区描述符对应的数据结构 */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BufferDesc</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tBufferTag\ttag;\t\t\t<span class=\"comment\">/* ID of page contained in buffer; 存储在缓冲区中页面的标识 */</span></span><br><span class=\"line\">\t<span class=\"type\">int</span>\t\tbuf_id;\t\t\t<span class=\"comment\">/* buffer&#x27;s index number (from 0); 缓冲的索引编号（从0开始） */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* state of the tag, containing flags, refcount and usagecount */</span></span><br><span class=\"line\">\tpg_atomic_uint32 state; \t\t<span class=\"comment\">/* tag的状态, 包含flags（标记位）, refcount（在本缓冲区上持有PIN的后端进程数）</span></span><br><span class=\"line\"><span class=\"comment\">\t                          \t\t , usagecount（时钟扫描要用到的引用计数）*/</span></span><br><span class=\"line\">                                \t\t<span class=\"comment\">/* 其中 flags保存的状态有以下几种：</span></span><br><span class=\"line\"><span class=\"comment\">                               \t   \t\t     1.脏位指明相应页面是否为脏页</span></span><br><span class=\"line\"><span class=\"comment\">                               \t   \t\t     2.有效位指明相应页面是否可以被读写</span></span><br><span class=\"line\"><span class=\"comment\">                               \t   \t\t     3.IO进行标记位指明缓冲区管理器是否正在从存储中读/写相应页面 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span>\t       wait_backend_pid;\t<span class=\"comment\">/* backend PID of pin-count waiter; 等着PIN本缓冲区的后端进程PID */</span></span><br><span class=\"line\">\t<span class=\"type\">int</span>\t       freeNext;\t\t<span class=\"comment\">/* link in freelist chain; 空闲链表中的链接 */</span></span><br><span class=\"line\">\tLWLock\t       content_lock;\t        <span class=\"comment\">/* to lock access to buffer contents; 访问缓冲区内容的锁 */</span></span><br><span class=\"line\">&#125; BufferDesc;</span><br></pre></td></tr></table></figure>\n<p>缓冲区描述符有三种状态：</p>\n<ul>\n<li><strong>空</strong>：当相应的缓冲池槽不存储页面时，即refcount与usagecount都是0，该描述符的状态为空。</li>\n<li><strong>钉住</strong>：当相应的缓冲池槽中存储着页面，且有PG进程正在访问相应页面时，即refcount与usagecount都大于等于1，该缓冲区描述符的状态为钉住。</li>\n<li><strong>未钉住</strong>：当相应的缓冲池槽中存储着页面，且没有PG进程正在访问相应页面时，即usagecount大于或等于1，但refcount为0，该描述符的状态为未钉住。</li>\n</ul>\n<h3 id=\"3、缓冲池\">3、缓冲池</h3>\n<p>缓冲池只是一个用于存储关系数据文件（例如表或索引）页面的简单数组。缓冲池数组的序号索引就是buffer_id。</p>\n<p>缓冲池槽的大小为8KB，等于页面大小，因此每个槽都能存储整个页面。</p>\n<h2 id=\"二、缓冲区管理器的工作原理\">二、缓冲区管理器的工作原理</h2>\n<p>当后端进程想要访问所需页面时，它会调用 <strong>ReadBufferExtended</strong> 函数。</p>\n<p>函数 ReadBufferExtended 的行为因场景而异，在逻辑上具体可以分为三种情况。</p>\n<h3 id=\"1、访问存储在缓冲池中的页面\">1、访问存储在缓冲池中的页面</h3>\n<p><strong>流程描述：</strong></p>\n<ol>\n<li>\n<p>创建所需页面的buffer tag，计算hash值；</p>\n</li>\n<li>\n<p>获取BufMappingLock分区锁，加shared锁；</p>\n</li>\n<li>\n<p>从buffer hashtable中找到buffer tag，获取buffer id；</p>\n</li>\n<li>\n<p>根据buffer id获取buffer descriptor；pin buffer；释放BufMappingLock分区锁；</p>\n</li>\n<li>\n<p>从Buffer Pool中获取buffer id对应的page。</p>\n<ul>\n<li>\n<p>在具体读取页面的行时，进程持有对应buffer descriptor的shared content_lock，多个进程可以并发读取。</p>\n</li>\n<li>\n<p>当修改该页面的行时，进程获取exclusive content_lock，dirty bit也要设为1。</p>\n</li>\n<li>\n<p>在获取页面后，对应的refcount要加1。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2、将页面从存储加载到空槽\">2、将页面从存储加载到空槽</h3>\n<p><strong>流程描述：</strong></p>\n<pre><code>1、查找buffer hashtable，没有找到对应的buffer tag；\n\n2、从freelist中获取第一个空的buffer descriptor，pin住\n\n\t1）获取buffer_strategy_lock自旋锁\n\n\t2）从空闲列表中弹出一个可用的buffer descriptor\n\n\t3）释放buffer_strategy_lock自旋锁\n\n\t4）pin buffer\n\n3、获取BufMappingLock分区锁，加exclusive锁；\n\n4、创建包含buffer tag和buffer id的hash entry，插入buffer hashtable；\n\n5、从存储中加载指定页到buffer pool，使用buffer id为数组下标\n\n\t1）获取exclusive io_in_progress_lock\n\n\t2）io_in_progress bit置1，防止其他进程获取buffer descriptor\n\n\t3）从存储中加载指定页到buffer pool\n\n\t4）修改buffer descriptor的状态，io_in_progress bit置0，valid bit置1\n\n\t5）释放io_in_progress_lock\n\n6、释放BufMappingLock分区锁；\n\n7、从Buffer Pool中获取buffer id对应的page；\n</code></pre>\n<h3 id=\"3、将页面从存储加载到受害者缓冲池槽\">3、将页面从存储加载到受害者缓冲池槽</h3>\n<p><strong>流程描述：</strong></p>\n<pre><code>1、查找buffer hashtable，没有找到对应的buffer tag；\n\n2、使用clock-sweep算法选中牺牲的buffer pool槽位，在buffer hashtable中获取包含牺牲槽位buffer id的旧表项，在buffer descriptor中pin住牺牲槽位；\n\n3、flush（write和fsync）牺牲槽位的页表数据，否则直接到4；\n\n\t 脏页必须先落盘，所占的slot才能被牺牲。刷脏包括以下步骤：\n\n\t1）获取buffer descriptor的shared content_lock和exclusive io_in_progress_lock\n\n\t2）修改buffer descriptor状态，io_in_progress bit置1，drity bit置0\n\n\t3）根据具体情况，使用XLogFlush将WAL缓冲区的WAL写入WAL段文件\n\n\t4）flush牺牲页\n\n\t5）修改buffer descriptor状态，io_in_progress置0，valid bit置1\n\n\t6）释放io_in_progress_lock和content_lock\n\n4、获取旧页表的exclusive BufMappingLock分区锁；\n\n5、获取新页表的exclusive BufMappingLock分区锁，添加到buffer table\n\n\t1）创建包含新buffer tag和buffer id的hash entry\n\n\t2）获取新的exclusive BufMappingLock分区锁\n\n\t3）插入到buffer hashtable\n\n6、删除buffer hashtable中旧的hash entry，释放旧的BufMappingLock分区锁；\n\n7、从存储中加载到牺牲slot，更新buffer descriptor的flag：dirty位置0，初始化其他bit；\n\n8、释放新的BufMappingLock分区锁；\n\n9、从Buffer Pool中获取指定buffer id对应的page；\n</code></pre>\n","categories":["PostgreSQL"],"tags":["DBMS"]},{"title":"PostgreSQL-调试initdb","url":"/0f842baa5beb/","content":"<p>1、gdb ./bin/initdb<br>\n2、set args -D ./data<br>\n3、在initdb.c 中打断点，最好位置设置在initialize_data_directory函数的setup_auth(cmdfd);<br>\n4、运行程序 r (run)<br>\n5、启动新窗口，查找进程，ps -ux<br>\n找到postgres --single -F -O -j -c search_path=pg_catalog -c exit_on_error=true template1<br>\n6、在新启动的窗口调试进程 （gdb att procid）</p>\n","categories":["PostgreSQL"],"tags":["DBMS"]},{"title":"PostgreSQL-xlog","url":"/b3574ee3d8f5/","content":"<h2 id=\"一、xlog存储结构\">一、xlog存储结构</h2>\n<p>​\t\t每个XLOG文件有一个ID，一个逻辑上的xlog文件物理上被分割成一个个固定大小的段（默认16MB）。xlog文件号和段号可以唯一确定某个段文件。确定日志文件内的一个日志记录的地址时，只需要xlog文件号和日志记录在该文件内的偏移量即可。</p>\n<span id=\"more\"></span>\n<p>​\t\t对于每一个Xlog文件第一个段的第一个页面是一个长头部（Long Header），一个xlog文件头部是不是长头部，可以由其头部XLogPageHeaderData的标志位xlp_info确定出来，如果是长头部，则：<br>\nXLogPageHeader page;<br>\npage-&gt;xlp_info = XLP_LONG_HEADER;</p>\n<h3 id=\"1、xlog日志页面头部信息\">1、xlog日志页面头部信息</h3>\n<p>​\t\txlog日志文件分为许多的逻辑段，每一个段文件又分成许多个页面，每一个页面大小为一个块的大小。对于每一个日志页面，需要在其头部写一个头部信息XLogPageHeaderData，其结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> XLOG_PAGE_MAGIC 0xD093\t<span class=\"comment\">/* can be used as WAL version indicator */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">XLogPageHeaderData</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tuint16\t\txlp_magic;\t\t<span class=\"comment\">/* 用于正确性检查的魔数 */</span></span><br><span class=\"line\">\tuint16\t\txlp_info;\t\t<span class=\"comment\">/* 标记位 */</span></span><br><span class=\"line\">\tTimeLineID\txlp_tli;\t\t<span class=\"comment\">/* 页面中第一条记录的时间线ID */</span></span><br><span class=\"line\">\tXLogRecPtr\txlp_pageaddr;\t<span class=\"comment\">/* 当前页面的XLOG地址 */</span></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * 当当前页面放不下一条完整记录时，我们会在下一个页面继续放，xlp_rem_len存储了先前页面</span></span><br><span class=\"line\"><span class=\"comment\">\t * 记录剩余的字节数。注意，xlp_rem_len包含了备份区块的数据，也就是说它会在第一个首部跟</span></span><br><span class=\"line\"><span class=\"comment\">\t * 踪xl_tot_len而不是xl_len。还要注意，数据不一定是对齐的。</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tuint32\t\txlp_rem_len;\t<span class=\"comment\">/* total len of remaining data for record */</span></span><br><span class=\"line\">&#125; XLogPageHeaderData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SizeOfXLogShortPHD\tMAXALIGN(sizeof(XLogPageHeaderData))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> XLogPageHeaderData *XLogPageHeader;</span><br></pre></td></tr></table></figure>\n<p>​\t\t如果一个页面是一个逻辑段文件的第一个页面，那么在页面头部信息标志位会设置XLP_LONG_HEADER标记，那么将在原页面头部信息的基础上使用一个长的XLOG页面头部XLogLongPageHeaderData，其结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 当xlp_info设置了XLP_LONG_HEADER标记位时，我们将在页首部中存储额外的字段。</span></span><br><span class=\"line\"><span class=\"comment\"> * (通常是在XLOG文件中的第一个页面中)额外的字段用于确保文件的正确性。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">XLogLongPageHeaderData</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tXLogPageHeaderData <span class=\"built_in\">std</span>;\t\t<span class=\"comment\">/* 标准首部 */</span></span><br><span class=\"line\">\tuint64\t\txlp_sysid;\t\t<span class=\"comment\">/* 来自pg_control中的系统标识符 */</span></span><br><span class=\"line\">\tuint32\t\txlp_seg_size;\t<span class=\"comment\">/* 交叉校验 */</span></span><br><span class=\"line\">\tuint32\t\txlp_xlog_blcksz;<span class=\"comment\">/* 交叉校验 */</span></span><br><span class=\"line\">&#125; XLogLongPageHeaderData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SizeOfXLogLongPHD\tMAXALIGN(sizeof(XLogLongPageHeaderData))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> XLogLongPageHeaderData *XLogLongPageHeader;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、xlog日志记录结构信息\">2、xlog日志记录结构信息</h3>\n<p>​\tXLOG Record由两部分组成，第一部分是XLOG Record的头部信息，大小固定（24 Bytes），对应的结构体是<strong>XLogRecord</strong>；第二部分是<strong>XLOG Record data</strong>。</p>\n<p>xlog记录存储布局：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">Fixed-size <span class=\"title function_\">header</span> <span class=\"params\">(XLogRecord <span class=\"keyword\">struct</span>)</span></span><br><span class=\"line\">XLogRecordBlockHeader <span class=\"keyword\">struct</span></span><br><span class=\"line\">XLogRecordBlockHeader <span class=\"keyword\">struct</span></span><br><span class=\"line\">…</span><br><span class=\"line\">XLogRecordDataHeader[Short|Long] <span class=\"keyword\">struct</span></span><br><span class=\"line\">block data</span><br><span class=\"line\">block data</span><br><span class=\"line\">…</span><br><span class=\"line\">main data</span><br></pre></td></tr></table></figure>\n<h4 id=\"1）XLogRecord\">1）XLogRecord</h4>\n<p><strong>XLOG Record</strong>按存储的数据内容来划分，大体可以分为三类：</p>\n<ul>\n<li>\n<p>Record for backup block：存储full-write-page的block，这种类型Record是为了解决page部分写的问题。在checkpoint完成后第一次修改数据page，在记                   \t\t\t\t\t\t\t\t\t\t\t   录此变更写入事务日志文件时整页写入（需设置参数full_page_write，默认为打开）；</p>\n</li>\n<li>\n<p>Record for tuple data block：存储page中的tuple变更，使用这种类型的Record记录；</p>\n</li>\n<li>\n<p>Record for Checkpoint：在checkpoint发生时，在事务日志文件中记录checkpoint信息。</p>\n</li>\n</ul>\n<p>XLogRecord记录了Xlog记录的相关控制信息:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//日志之间有链接关系，xl_prev指向上一条日志的起始位置，下一条日志的位置用xl_tot_len可以找到，日志之间形成“双向链表”。</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">XLogRecord</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//整条XLog记录的长度</span></span><br><span class=\"line\">\tuint32\t\txl_tot_len;\t\t<span class=\"comment\">/* total len of entire record */</span></span><br><span class=\"line\">    <span class=\"comment\">//事务ID</span></span><br><span class=\"line\">\tTransactionId xl_xid;\t\t<span class=\"comment\">/* xact id */</span></span><br><span class=\"line\">    <span class=\"comment\">//上一条日志的LSN</span></span><br><span class=\"line\">\tXLogRecPtr\txl_prev;\t\t<span class=\"comment\">/* ptr to previous record in log */</span></span><br><span class=\"line\">    <span class=\"comment\">//产生这个记录的动作，xl_info低4位保存flag信息，高4位保存日志动作信息。</span></span><br><span class=\"line\">\tuint8\t\txl_info;\t\t<span class=\"comment\">/* flag bits, see below */</span></span><br><span class=\"line\">    <span class=\"comment\">//日志记录对应的资源管理器</span></span><br><span class=\"line\">\tRmgrId\t\txl_rmid;\t\t<span class=\"comment\">/* resource manager for this record */</span></span><br><span class=\"line\">\t<span class=\"comment\">/* 2 bytes of padding here, initialize to zero */</span></span><br><span class=\"line\">    <span class=\"comment\">//本记录的CRC</span></span><br><span class=\"line\">\tpg_crc32c\txl_crc;\t\t\t<span class=\"comment\">/* CRC for this record */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* XLogRecordBlockHeaders and XLogRecordDataHeader follow, no padding */</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; XLogRecord;</span><br></pre></td></tr></table></figure>\n<p>其中，xl_info被资源管理器使用，表示该日志是哪种类型的日志，其取值如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* XLOG info values for XLOG rmgr */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> XLOG_CHECKPOINT_SHUTDOWN\t\t0x00</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> XLOG_CHECKPOINT_ONLINE\t\t\t0x10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> XLOG_NOOP\t\t\t\t\t\t0x20</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> XLOG_NEXTOID\t\t\t\t\t0x30</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> XLOG_SWITCH\t\t\t\t\t\t0x40</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> XLOG_BACKUP_END\t\t\t\t\t0x50</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> XLOG_PARAMETER_CHANGE\t\t\t0x60</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> XLOG_RESTORE_POINT\t\t\t\t0x70</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> XLOG_FPW_CHANGE\t\t\t\t\t0x80</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> XLOG_END_OF_RECOVERY\t\t\t0x90</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> XLOG_FPI_FOR_HINT\t\t\t\t0xA0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> XLOG_FPI\t\t\t\t\t\t0xB0</span></span><br><span class=\"line\"><span class=\"comment\">/* 0xC0 is used in Postgres 9.5-11 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> XLOG_OVERWRITE_CONTRECORD\t\t0xD0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2）XLOG-Record-data\">2）XLOG Record data</h4>\n<p><strong>XLOG Record data</strong>是存储实际数据的地方，由以下几部分组成：</p>\n<ul>\n<li>\n<p>0…N个XLogRecordBlockHeader，每一个XLogRecordBlockHeader对应一个block data；</p>\n</li>\n<li>\n<p>XLogRecordDataHeader[Short|Long]，如数据大小&lt;256 Bytes，则使用Short格式，否则使用Long格式；</p>\n</li>\n<li>\n<p>block data：full-write-page data和tuple data。对于full-write-page data，如启用了压缩，则数据压缩存储，压缩后该page相关的元数据存储在XLogRecordBlockCompressHeader中。block data的个数和XLogRecordBlockHeader对应；</p>\n</li>\n<li>\n<p>main data： checkpoint等日志数据.</p>\n</li>\n</ul>\n<hr>\n<h5 id=\"（1）BLOCK\">（1）BLOCK</h5>\n<h6 id=\"①XLogRecordBlockHeader\">①XLogRecordBlockHeader</h6>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">XLogRecordBlockHeader</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//【一个记录中可以有多个block（MAX: 32），此id是block的序号】</span></span><br><span class=\"line\">\tuint8\t\tid;\t\t\t\t<span class=\"comment\">/* block reference ID */</span></span><br><span class=\"line\">    <span class=\"comment\">//【关系中的分支，以及标记位】</span></span><br><span class=\"line\">\tuint8\t\tfork_flags;\t\t<span class=\"comment\">/* fork within the relation, and flags */</span></span><br><span class=\"line\">    <span class=\"comment\">//【决定tupledata中存储的数据的长度(不包括page image)】</span></span><br><span class=\"line\">\tuint16\t\tdata_length;\t<span class=\"comment\">/* number of payload bytes (not including page</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t * image) */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* If BKPBLOCK_HAS_IMAGE, an XLogRecordBlockImageHeader struct follows */</span></span><br><span class=\"line\">\t<span class=\"comment\">/* If BKPBLOCK_SAME_REL is not set, a RelFileNode follows */</span></span><br><span class=\"line\">\t<span class=\"comment\">/* BlockNumber follows */</span></span><br><span class=\"line\">&#125; XLogRecordBlockHeader;</span><br></pre></td></tr></table></figure>\n<hr>\n<h6 id=\"②XLogRecordBlockImageHeader\">②XLogRecordBlockImageHeader</h6>\n<p>wal记录是一个full page write记录时，存在此结构</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">XLogRecordBlockImageHeader</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//【保存的page的总长度（去除空洞数据、且压缩后的长度）】</span></span><br><span class=\"line\">\tuint16\t\tlength;\t\t\t<span class=\"comment\">/* number of page image bytes */</span></span><br><span class=\"line\">    <span class=\"comment\">//【空洞前面的字节数】</span></span><br><span class=\"line\">\tuint16\t\thole_offset;\t<span class=\"comment\">/* number of bytes before &quot;hole&quot; */</span></span><br><span class=\"line\">    <span class=\"comment\">//【标志位，记录是否包含空洞数据，是否进行了压缩】</span></span><br><span class=\"line\">\tuint8\t\tbimg_info;\t\t<span class=\"comment\">/* flag bits, see below */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * If BKPIMAGE_HAS_HOLE and BKPIMAGE_IS_COMPRESSED, an</span></span><br><span class=\"line\"><span class=\"comment\">\t * XLogRecordBlockCompressHeader struct follows.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">&#125; XLogRecordBlockImageHeader</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bimg_info可能的取值如下：</span></span><br><span class=\"line\"><span class=\"comment\">/* Information stored in bimg_info */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BKPIMAGE_HAS_HOLE\t\t0x01\t<span class=\"comment\">/* page image has &quot;hole&quot; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BKPIMAGE_IS_COMPRESSED\t0x02\t<span class=\"comment\">/* page image is compressed */</span></span></span><br></pre></td></tr></table></figure>\n<h6 id=\"③XLogRecordBlockCompressHeader\">③XLogRecordBlockCompressHeader</h6>\n<p>此结构记录空洞数据的大小</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Extra header information used when page image has &quot;hole&quot; and</span></span><br><span class=\"line\"><span class=\"comment\"> * is compressed.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">XLogRecordBlockCompressHeader</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tuint16\t\thole_length;\t<span class=\"comment\">/* number of bytes in &quot;hole&quot; */</span></span><br><span class=\"line\">&#125; XLogRecordBlockCompressHeader;</span><br></pre></td></tr></table></figure>\n<h6 id=\"④RelFileNode\">④RelFileNode</h6>\n<p>此结构记录了此block所属的表。如果当前block与前一个block来源于同一个表时，那么fork_flags中就不会有BKPBLOCK_SAME_REL标志位</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">RelFileNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tOid\t\t\tspcNode;\t\t<span class=\"comment\">/* tablespace */</span></span><br><span class=\"line\">\tOid\t\t\tdbNode;\t\t\t<span class=\"comment\">/* database */</span></span><br><span class=\"line\">\tOid\t\t\trelNode;\t\t<span class=\"comment\">/* relation */</span></span><br><span class=\"line\">&#125; RelFileNode;</span><br></pre></td></tr></table></figure>\n<h6 id=\"⑤BlockNumber\">⑤BlockNumber</h6>\n<p>记录此block记录的page的块号。</p>\n<hr>\n<h5 id=\"（2）XLogRecordDataHeaderLong-XLogRecordDataHeaderShort\">（2）XLogRecordDataHeaderLong/XLogRecordDataHeaderShort</h5>\n<p>此结构被record中的maindata(checkpoint等日志数据)部分使用，当maindata的size小于256时使用XLogRecordDataHeaderShort结构<br>\n否则使用XLogRecordDataHeaderLong结构</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">XLogRecordDataHeaderShort</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tuint8\t\tid;\t\t\t\t<span class=\"comment\">/* XLR_BLOCK_ID_DATA_SHORT */</span></span><br><span class=\"line\">\tuint8\t\tdata_length;\t<span class=\"comment\">/* number of payload bytes */</span></span><br><span class=\"line\">&#125;\tXLogRecordDataHeaderShort;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">XLogRecordDataHeaderLong</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tuint8\t\tid;\t\t\t\t<span class=\"comment\">/* XLR_BLOCK_ID_DATA_LONG */</span></span><br><span class=\"line\">\t<span class=\"comment\">/* followed by uint32 data_length, unaligned */</span></span><br><span class=\"line\">&#125;\tXLogRecordDataHeaderLong;</span><br></pre></td></tr></table></figure>\n<h5 id=\"（3）block-data（区块数据与XLogRecordBlockHeader对应）\">（3）block data（区块数据与XLogRecordBlockHeader对应）</h5>\n<p>block data包含full-write-page data（全页写日志记录）和tuple data（更新日志记录）两种类型数据</p>\n<h5 id=\"（4）main-data（主数据与XLogRecordDataHeader对应）\">（4）main data（主数据与XLogRecordDataHeader对应）</h5>\n<p>main data部分保存非buff性的数据，比如checkpoint等日志数据.</p>\n<h2 id=\"二、xlog记录写入\">二、xlog记录写入</h2>\n","categories":["PostgreSQL"],"tags":["DBMS"]},{"title":"gdb常用命令","url":"/d50131e451e4/","content":"<hr>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#psql查看当前窗口进程：select  pg_backend_pid();</span><br><span class=\"line\"></span><br><span class=\"line\">#gdb关联进程：gdb attach 进程号</span><br><span class=\"line\"></span><br><span class=\"line\">#gdb查看堆栈信息：bt</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#1. 显示源代码窗口</span></span><br><span class=\"line\">(gdb) layout src</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#2. 显示寄存器窗口</span></span><br><span class=\"line\">(gdb) layout regs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#3. 显示汇编代码窗口</span></span><br><span class=\"line\">(gdb) layout asm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#4. 显示源代码和汇编代码</span></span><br><span class=\"line\">(gdb) layout <span class=\"built_in\">split</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#5. 显示窗口的大小</span></span><br><span class=\"line\">info win</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#6. 切换到下一个布局模式</span></span><br><span class=\"line\">layout next</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#7. 切换到上一个布局模式</span></span><br><span class=\"line\">layout prev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#8. 切换当前窗口</span></span><br><span class=\"line\">focus cmd/src/asm/regs/next/prev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#9. 刷新所有窗口</span></span><br><span class=\"line\">refresh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#10. 更新源代码窗口和当前执行点</span></span><br><span class=\"line\">update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#11. 调整name窗口的高度</span></span><br><span class=\"line\">winheight name +/- line</span><br></pre></td></tr></table></figure>\n<hr>\n","tags":["gdb"]},{"title":"gdb调试堆栈只显示问号","url":"/dc9302aa5d89/","content":"<p><a href=\"https://blog.csdn.net/mseaspring/article/details/106346247\">程序挂了，GDB 调试只显示问号</a></p>\n","tags":["gdb"]},{"title":"linux命令汇总","url":"/86e57d597029/","content":"","tags":["IT运维"]},{"title":"检查链表的边界条件","url":"/040be08fc1bb/","content":"<ul>\n<li>如果链表<font color=Darkorange>为空</font>时，代码是否能正常工作？</li>\n<li>如果链表<font color=Darkorange>只包含一个结点</font>时，代码是否能正常工作？</li>\n<li>如果链表<font color=Darkorange>只包含两个结点</font>时，代码是否能正常工作？</li>\n<li>代码逻辑在<font color=Darkorange>处理头结点和尾结点</font>的时候，是否能正常工作？</li>\n</ul>\n","categories":["算法"],"tags":["链表"]}]